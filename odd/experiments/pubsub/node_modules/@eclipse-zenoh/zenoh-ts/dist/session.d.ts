import { IntoKeyExpr, KeyExpr } from "./key_expr.js";
import { IntoZBytes } from "./z_bytes.js";
import { Liveliness } from "./liveliness.js";
import { IntoSelector, Query, Queryable, Reply } from "./query.js";
import { Publisher, Subscriber } from "./pubsub.js";
import { Config } from "./config.js";
import { IntoEncoding } from "./encoding.js";
import { TimeDuration } from 'typed-duration';
import { Timestamp } from "./timestamp.js";
import { ChannelReceiver, Handler } from "./channels.js";
import { ZenohId } from "./zid.js";
import { CongestionControl, ConsolidationMode, Locality, Priority, QueryTarget, Reliability, ReplyKeyExpr } from "./enums.js";
import { Sample } from "./sample.js";
import { Querier } from "./querier.js";
import { CancellationToken } from "./cancellation_token.js";
export declare const DEFAULT_QUERY_TIMEOUT_MS = 10000;
/**
 * Options for a Put operation
 * @prop {Encoding=} encoding - Encoding type
 * @prop {CongestionControl=} congestionControl - Congestion control applied when routing the data
 * @prop {Priority=} priority - Priority of the written data
 * @prop {boolean=} express  - Express: if set to `true`, this message will not be batched. This usually has a positive impact on latency but negative impact on throughput.
 * @prop {Reliability=} reliability  - Reliability to apply to data transport,
 * @prop {Locality=} allowedDestination - Allowed destination for the data,
 * @prop {IntoZBytes=} attachment - Additional Data to send with the request
 * @prop {Timestamp=} timestamp - Timestamp of the message
*/
export interface PutOptions {
    encoding?: IntoEncoding;
    congestionControl?: CongestionControl;
    priority?: Priority;
    express?: boolean;
    reliability?: Reliability;
    allowedDestination?: Locality;
    attachment?: IntoZBytes;
    timestamp?: Timestamp;
}
/**
 * Options for a Delete operation
 * @prop {CongestionControl=} congestion_control - Congestion control applied when routing the data
 * @prop {Priority=} priority - Prriority of the written data
 * @prop {boolean=} express  - Express: if set to `true`, this message will not be batched. This usually has a positive impact on latency but negative impact on throughput.
 * @prop {Reliability=} reliability  - Reliability to apply to data transport
 * @prop {Locality=} allowedDestination - Allowed destination for the data
 * @prop {IntoZBytes=} attachment - Additional Data sent with the request
 * @prop {Timestamp=} timestamp - Timestamp of the message
*/
export interface DeleteOptions {
    congestionControl?: CongestionControl;
    priority?: Priority;
    express?: boolean;
    reliability?: Reliability;
    allowedDestination?: Locality;
    attachment?: IntoZBytes;
    timestamp?: Timestamp;
}
/**
 * Options for a Get operation
 * @prop {CongestionControl=} congestion_control - Congestion control applied when routing the data
 * @prop {Priority=} priority - Priority of the query
 * @prop {boolean=} express  - Express: if set to `true`, this query will not be batched. This usually has a positive impact on latency but negative impact on throughput.
 * @prop {Locality=} allowedDestination - Allowed destination for the query
 * @prop {IntoEncoding=} encoding - Encoding type of payload
 * @prop {IntoZBytes=} payload - Payload associated with the query
 * @prop {IntoZBytes=} attachment - Additional Data sent with the query
 * @prop {TimeDuration=} timeout - Timeout value for a query
 * @prop {ConsolidationMode=} consolidation - Consolidation mode
 * @prop {QueryTarget=} target - Queryables this query should target
 * @prop {ReplyKeyExpr=} acceptReplies - Replies this query accepts
 * @prop {Handler<Reply>=} handler - A reply handler
 * @prop {CancellationToken=} cancellationToken - Token to interrupt the query. Warning: This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
*/
export interface GetOptions {
    congestionControl?: CongestionControl;
    priority?: Priority;
    express?: boolean;
    allowedDestination?: Locality;
    encoding?: IntoEncoding;
    payload?: IntoZBytes;
    attachment?: IntoZBytes;
    timeout?: TimeDuration;
    target?: QueryTarget;
    consolidation?: ConsolidationMode;
    acceptReplies?: ReplyKeyExpr;
    cancellationToken?: CancellationToken;
    handler?: Handler<Reply>;
}
/**
 * Options for a Queryable
 * @prop {boolean?} complete - Queryable completness.
 * @prop {Locality=} allowedOrigin - Origin of queries, this queryable should reply to
 * @prop {Handler<Query>=} handler - A query handler
*/
export interface QueryableOptions {
    complete?: boolean;
    allowedOrigin?: Locality;
    handler?: Handler<Query>;
}
/**
 * Options for a Publisher
 * @prop {Encoding=} encoding - Default publisher encoding, that will be applied if no encoding is specified when sending individual messages.
 * @prop {CongestionControl=} congestionControl - Congestion control to be applied to messages sent with this publisher
 * @prop {Priority=} priority - The Priority of messages sent with this publisher
 * @prop {boolean=} express - Express setting for messages sent with this publisher. If set to `true`, the messages will not be batched. This usually has a positive impact on latency but negative impact on throughput.
 * @prop {Reliability=} reliability - Reliability of messages sent with this publisher
 * @prop {Locality=} allowedDestination - Allowed destination for the messages sent with this publisher
 */
export interface PublisherOptions {
    encoding?: IntoEncoding;
    congestionControl?: CongestionControl;
    priority?: Priority;
    express?: boolean;
    reliability?: Reliability;
    allowedDestination?: Locality;
}
/**
 * Options for a Subscriber
 * @prop {Locality=} allowedOrigin - Origin of messages this subscriber can receive
 * @prop {Handler<Sample=>} handler - Handler for this subscriber
 */
export interface SubscriberOptions {
    allowedOrigin?: Locality;
    handler?: Handler<Sample>;
}
/**
 * Options for a Querier
 * @prop {CongestionControl=} congestion_control - Congestion control applied when routing this Querier queries
 * @prop {Priority=} priority - Priority of this Querier's queries
 * @prop {boolean=} express  - Express: If set to `true`, this query will not be batched. This usually has a positive impact on latency but negative impact on throughput.
 * @prop {Locality=} allowedDestination - Allowed destination for this Querier queries
 * @prop {TimeDuration=} timeout - Timeout value for this Querier queries
 * @prop {QueryTarget=} target - Queryables this Querier queries should target
 * @prop {ConsolidationMode=} consolidation - Consolidation mode for this Querier queries
 * @prop {ReplyKeyExpr=} acceptReplies - Replies this Querier queries accept
 */
export interface QuerierOptions {
    congestionControl?: CongestionControl;
    priority?: Priority;
    express?: boolean;
    consolidation?: ConsolidationMode;
    target?: QueryTarget;
    timeout?: TimeDuration;
    allowedDestination?: Locality;
    acceptReplies?: ReplyKeyExpr;
}
/**
 * Zenoh Session
 */
export declare class Session {
    private inner;
    [Symbol.asyncDispose](): Promise<void>;
    private constructor();
    /**
     * Creates a new Session instance
     *
     * @remarks
     *  Opens A Zenoh Session
     *
     * @param config - Config for session
     * @returns Typescript instance of a Session
     *
     */
    static open(config: Config): Promise<Session>;
    /**
     * Closes a session, cleaning up the resource in Zenoh
     *
     * @returns Nothing
     */
    close(): Promise<void>;
    isClosed(): boolean;
    /**
     * Puts a value on the session, on a specific key expression
     *
     * @param {IntoKeyExpr} intoKeyExpr - key expression to publish to
     * @param {IntoZBytes} intoZBytes - payload to publish
     * @param {PutOptions=} putOpts - optional additional parameters to pass to delete operation
     * @returns void
     */
    put(intoKeyExpr: IntoKeyExpr, intoZBytes: IntoZBytes, putOpts?: PutOptions): Promise<void>;
    /**
     * Creates a Key Expression
     *
     * @returns KeyExpr
     */
    declareKeyexpr(intoKeyExpr: IntoKeyExpr): KeyExpr;
    /**
     * Returns the Zenoh SessionInfo Object
     *
     * @returns SessionInfo
     */
    info(): Promise<SessionInfo>;
    /**
     * Executes a Delete on a session, for a specific key expression KeyExpr
     *
     * @param {IntoKeyExpr} intoKeyExpr - something that implements intoKeyExpr
     * @param {DeleteOptions} deleteOpts - optional additional parameters to pass to delete operation
     *
     * @returns void
     */
    delete(intoKeyExpr: IntoKeyExpr, deleteOpts?: DeleteOptions): Promise<void>;
    /**
     * Issues a get query on a Zenoh session
     *
     * @param intoSelector - representing a KeyExpr and Parameters
     * @param {GetOptions=} getOpts - optional additional parameters to pass to get operation
     *
     * @returns Receiver
     */
    get(intoSelector: IntoSelector, getOpts?: GetOptions): Promise<ChannelReceiver<Reply> | undefined>;
    /**
     * Declares a new subscriber
     *
     * @remarks
     *  If a Subscriber is created with a callback, it cannot be simultaneously polled for new values
     *
     * @param {IntoKeyExpr} intoKeyExpr - the key expression to subscribe to
     * @param {SubscriberOptions} subscriberOpts - optional additional parameters to pass to subscriber declaration
     *
     * @returns Subscriber
     */
    declareSubscriber(intoKeyExpr: IntoKeyExpr, subscriberOpts?: SubscriberOptions): Promise<Subscriber>;
    /**
     * Obtain a Liveliness struct tied to this Zenoh Session.
     *
     * @returns Liveliness
     */
    liveliness(): Liveliness;
    /**
     * Creates a new Timestamp instance
     *
     * @returns Timestamp
     */
    newTimestamp(): Promise<Timestamp>;
    /**
    * Declares a new Queryable
    *
    * @param {IntoKeyExpr} intoKeyExpr - Queryable key expression
    * @param {QueryableOptions=} queryableOpts - Optional additional settings for a Queryable [QueryableOptions]
    *
    * @returns Queryable
    */
    declareQueryable(intoKeyExpr: IntoKeyExpr, queryableOpts?: QueryableOptions): Promise<Queryable>;
    /**
    * Declares a new Publisher
    *
    * @param {IntoKeyExpr} intoKeyExpr - Publisher's key expression
    * @param {PublisherOptions=} publisherOpts - Optional additional settings for a Publisher [PublisherOptions]
    * @returns Publisher
    */
    declarePublisher(intoKeyExpr: IntoKeyExpr, publisherOpts?: PublisherOptions): Promise<Publisher>;
    /**
    * Declares a Querier
    *
    * @param {IntoKeyExpr} intoKeyexpr - Querier's key expression
    * @param {QuerierOptions=} querierOpts - Optional additional settings for a Querier [QuerierOptions]
    * @returns Publisher
    */
    declareQuerier(intoKeyexpr: IntoKeyExpr, querierOpts?: QuerierOptions): Promise<Querier>;
}
/**
 *  Function to open a Zenoh session
 */
export declare function open(config: Config): Promise<Session>;
/**
 *  Struct to expose Info for Zenoh Session
 */
export declare class SessionInfo {
    private zid_;
    private peers_;
    private routers_;
    constructor(zid_: ZenohId, peers_: ZenohId[], routers_: ZenohId[]);
    zid(): ZenohId;
    routersZid(): ZenohId[];
    peersZid(): ZenohId[];
}
