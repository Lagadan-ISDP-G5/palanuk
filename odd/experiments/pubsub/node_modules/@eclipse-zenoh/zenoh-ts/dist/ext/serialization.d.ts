import { ZBytes } from '../z_bytes.js';
/**
 * Interface for adding support for custom types serialization.
 */
export interface ZSerializeable {
    serializeWithZSerializer(serializer: ZBytesSerializer): void;
}
/**
 * Interface for adding support for custom types deserialization.
 */
export interface ZDeserializeable {
    deserializeWithZDeserializer(deserializer: ZBytesDeserializer): void;
}
type IsSame<T, U> = (<G>() => G extends T ? 1 : 2) extends (<G>() => G extends U ? 1 : 2) ? T : never;
type UnionToIntersection<U> = (U extends any ? (x: U) => void : never) extends ((x: infer I) => void) ? I : never;
type IsNotUnion<T> = [T] extends [UnionToIntersection<T>] ? T : IsSame<T, boolean>;
type Select<X, Y, Z> = (X & Y) extends never ? never : Z;
type IsSerializeableInner<T, X = T> = T extends ZSerializeable ? X : T extends number ? X : T extends bigint ? X : T extends string ? X : T extends boolean ? X : T extends Uint8Array<infer _> ? X : T extends Uint16Array<infer _> ? X : T extends Uint32Array<infer _> ? X : T extends BigUint64Array<infer _> ? X : T extends Int8Array<infer _> ? X : T extends Int16Array<infer _> ? X : T extends Int32Array<infer _> ? X : T extends BigInt64Array<infer _> ? X : T extends Float32Array<infer _> ? X : T extends Float64Array<infer _> ? X : T extends Array<infer U> ? EnsureSerializeable<U, X> : T extends Map<infer K, infer V> ? EnsureSerializeable<K, X> & EnsureSerializeable<V, X> : never;
export type EnsureSerializeable<T, X = T> = Select<IsSerializeableInner<T>, IsNotUnion<T>, X>;
/**
 * A Zenoh serializer.
 * Provides functionality for tuple-like serialization.
 */
export declare class ZBytesSerializer {
    private static readonly DEFAULT_BUFFER_SIZE;
    private static readonly MAX_SEQUENCE_LENGTH_TO_FIT_IN_SINGLE_BYTE;
    private buffer;
    private bufferLen;
    private data;
    private len;
    private resetBuffer;
    private ensureBuffer;
    /**
     * new function to create a ZBytesSerializer.
     *
     * @returns ZBytesSerializer
     */
    constructor();
    private append;
    /**
     * Serializes length of the sequence. Can be used when defining serialization for custom containers.
     */
    writeSequenceLength(len: number): void;
    /**
     * Serializes a utf-8 encoded string.
     */
    serializeString(val: string): void;
    /**
     * Serializes a Uint8Array.
     */
    serializeUint8Array<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike>(val: Uint8Array<TArrayBuffer>): void;
    /**
     * Serializes a Uint16Array.
     */
    serializeUint16Array<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike>(val: Uint16Array<TArrayBuffer>): void;
    /**
     * Serializes a Uint32Array.
     */
    serializeUint32Array<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike>(val: Uint32Array<TArrayBuffer>): void;
    /**
     * Serializes a BigUint64Array.
     */
    serializeBiguint64Array<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike>(val: BigUint64Array<TArrayBuffer>): void;
    /**
     * Serializes a Int8Array.
     */
    serializeInt8Array<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike>(val: Int8Array<TArrayBuffer>): void;
    /**
     * Serializes a Int16Array.
     */
    serializeInt16Array<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike>(val: Int16Array<TArrayBuffer>): void;
    /**
     * Serializes a Int32Array.
     */
    serializeInt32Array<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike>(val: Int32Array<TArrayBuffer>): void;
    /**
     * Serializes a BigInt64Array.
     */
    serializeBigint64Array<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike>(val: BigInt64Array<TArrayBuffer>): void;
    /**
     * Serializes a Float32Array.
     */
    serializeFloat32Array<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike>(val: Float32Array<TArrayBuffer>): void;
    /**
     * Serializes a Float64Array.
     */
    serializeFloat64Array<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike>(val: Float64Array<TArrayBuffer>): void;
    /**
     * Serializes bigint as 64 bit signed integer.
     */
    serializeBigintInt64(val: bigint): void;
    /**
     * Serializes bigint as 64 bit unsigned integer.
     */
    serializeBigintUint64(val: bigint): void;
    /**
     * Serializes number as 64 bit floating point number.
     */
    serializeNumberFloat64(val: number): void;
    /**
     * Serializes number as 32 bit floating point number.
     */
    serializeNumberFloat32(val: number): void;
    /**
     * Serializes number as 64 bit integer.
     */
    serializeNumberInt64(val: number): void;
    /**
     * Serializes number as 64 bit unsigned integer.
     */
    serializeNumberUint64(val: number): void;
    /**
     * Serializes number as 32 bit integer.
     */
    serializeNumberInt32(val: number): void;
    /**
     * Serializes number as 32 bit unsigned integer.
     */
    serializeNumberUint32(val: number): void;
    /**
     * Serializes number as 16 bit integer.
     */
    serializeNumberInt16(val: number): void;
    /**
     * Serializes number as 16 bit unsigned integer.
     */
    serializeNumberUint16(val: number): void;
    /**
     * Serializes number as 8 bit integer.
     */
    serializeNumberInt8(val: number): void;
    /**
     * Serializes number as 8 bit unsigned integer.
     */
    serializeNumberUint8(val: number): void;
    /**
     * Serializes boolean.
     */
    serializeBoolean(val: Boolean): void;
    /**
     * Serializes an array.
     */
    serializeArray<T>(val: EnsureSerializeable<T>[], t?: ZSTypeInfo<EnsureSerializeable<T>>): void;
    /**
     * Serializes a map.
     */
    serializeMap<K, V>(m: Map<EnsureSerializeable<K>, EnsureSerializeable<V>>, tKey?: ZSTypeInfo<EnsureSerializeable<K>>, tValue?: ZSTypeInfo<EnsureSerializeable<V>>): void;
    private getDefaultSerializationTag;
    /**
     * Serializes any supported type and append it to existing serialized payload.
     * Supported types are:
     *   - built-in types: number, bigint, string, boolean,
     *   - TypedArrays,
     *   - arrays and maps of supported types.
     * @param val Value to serialize.
     * @param t An optional serialization tag (if ommited, the default one will be used).
     */
    serialize<T>(val: EnsureSerializeable<T>, t?: ZSTypeInfo<EnsureSerializeable<T>>): void;
    /**
     * Extracts ZBytes from ZBytesSerializer
     *
     * @returns ZBytes
     */
    finish(): ZBytes;
    /**
    * Extracts currently serialized bytes.
    *
    * @returns ZBytes
    */
    toBytes(): Uint8Array;
}
/**
 * Format for `number` type serialization/deserialzation.
 */
export declare enum NumberFormat {
    Float64 = 1,
    Float32 = 2,
    Int64 = 3,
    Uint64 = 4,
    Int32 = 5,
    Uint32 = 6,
    Int16 = 7,
    Uint16 = 8,
    Int8 = 9,
    Uint8 = 10
}
/**
 * Format for `bigint` type serialization/deserialzation.
 */
export declare enum BigIntFormat {
    Int64 = 1,
    Uint64 = 2
}
declare class ZDTypeInfo<T> {
    private deserialize_;
    constructor(deserialize_: (deserializer: ZBytesDeserializer) => T);
    /** @internal */
    deserialize(deserializer: ZBytesDeserializer): T;
}
declare class ZSTypeInfo<T> {
    private serialize_;
    constructor(serialize_: (serializer: ZBytesSerializer, val: T) => void);
    /** @internal */
    serialize(serializer: ZBytesSerializer, val: T): void;
}
export declare namespace ZD {
    /**
     * Indicates that value should be deserialized as a number in specified format.
     * @returns Number deserialization tag.
     */
    function number(format?: NumberFormat): ZDTypeInfo<number>;
    /**
     * Indicates that data should be deserialized as a bigint in specified format.
     * @returns Bigint deserialization tag.
     */
    function bigint(format?: BigIntFormat): ZDTypeInfo<bigint>;
    /**
     * Indicates that data should be deserialized as a string.
     * @returns String deserialization tag.
     */
    function string(): ZDTypeInfo<string>;
    /**
     * Indicates that data should be deserialized as a boolean.
     * @returns Boolean deserialization tag.
     */
    function boolean(): ZDTypeInfo<boolean>;
    /**
     * Indicates that data should be deserialized as a Uint8Array.
     * @returns Uint8Array deserialization tag.
     */
    function uint8array(): ZDTypeInfo<Uint8Array>;
    /**
     * Indicates that data should be deserialized as a Uint16Array.
     * @returns Uint16Array deserialization tag.
     */
    function uint16array(): ZDTypeInfo<Uint16Array>;
    /**
     * Indicates that data should be deserialized as a Uint32Array.
     * @returns Uint32Array deserialization tag.
     */
    function uint32array(): ZDTypeInfo<Uint32Array>;
    /**
     * Indicates that data should be deserialized as a BigUint64Array.
     * @returns BigUint64Array deserialization tag.
     */
    function biguint64array(): ZDTypeInfo<BigUint64Array>;
    /**
     * Indicates that data should be deserialized as a Int8Array.
     * @returns Int8Array deserialization tag.
     */
    function int8array(): ZDTypeInfo<Int8Array>;
    /**
     * Indicates that data should be deserialized as a Int16Array.
     * @returns Int16Array deserialization tag.
     */
    function int16array(): ZDTypeInfo<Int16Array>;
    /**
     * Indicates that data should be deserialized as a Int32Array.
     * @returns Int32Array deserialization tag.
     */
    function int32array(): ZDTypeInfo<Int32Array>;
    /**
     * Indicates that data should be deserialized as a BigInt64Array.
     * @returns BigInt64Array deserialization tag.
     */
    function bigint64array(): ZDTypeInfo<BigInt64Array>;
    /**
     * Indicates that data should be deserialized as a Float32Array.
     * @returns Float32Array deserialization tag.
     */
    function float32array(): ZDTypeInfo<Float32Array>;
    /**
     * Indicates that data should be deserialized as a Float64Array.
     * @returns Float64Array deserialization tag.
     */
    function float64array(): ZDTypeInfo<Float64Array>;
    /**
     * Indicates that data should be deserialized as an object.
     * @param create A new function to create an object instance where data will be deserialized.
     * @returns Object deserialization tag.
     */
    function object<T extends ZDeserializeable>(create: new () => T): ZDTypeInfo<T>;
    /**
     * Indicates that data should be deserialized as an object.
     * @param create A function to create an object instance from deserializer.
     * @returns Object deserialization tag.
     */
    function objectStatic<T>(create: (deserializer: ZBytesDeserializer) => T): ZDTypeInfo<T>;
    /**
     * Indicates that data should be deserialized as an array.
     * @param t An array element deserialization tag.
     * @returns Array deserialization tag.
     */
    function array<T>(t: ZDTypeInfo<T>): ZDTypeInfo<T[]>;
    /**
     * Indicates that data should be deserialized as a map.
     * @param tKey A key type deserialization tag.
     * @param tValue A value type deserialization tag.
     * @returns Array deserialization tag.
     */
    function map<K, V>(tKey: ZDTypeInfo<K>, tValue: ZDTypeInfo<V>): ZDTypeInfo<Map<K, V>>;
}
export declare namespace ZS {
    /**
     * Indicates that value should be serialized as a number in specified format.
     * @returns Number serialization tag.
     */
    function number(format?: NumberFormat): ZSTypeInfo<number>;
    /**
     * Indicates that data should be serialized as a bigint in specified format.
     * @returns Bigint serialization tag.
     */
    function bigint(format?: BigIntFormat): ZSTypeInfo<bigint>;
    /**
     * Indicates that data should be serialized as a string.
     * @returns String serialization tag.
     */
    function string(): ZSTypeInfo<string>;
    /**
     * Indicates that data should be serialized as a boolean.
     * @returns Boolean serialization tag.
     */
    function boolean(): ZSTypeInfo<boolean>;
    /**
     * Indicates that data should be serialized as a Uint8Array.
     * @returns Uint8Array serialization tag.
     */
    function uint8array<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike>(): ZSTypeInfo<Uint8Array<TArrayBuffer>>;
    /**
     * Indicates that data should be serialized as a Uint16Array.
     * @returns Uint16Array serialization tag.
     */
    function uint16array<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike>(): ZSTypeInfo<Uint16Array<TArrayBuffer>>;
    /**
     * Indicates that data should be serialized as a Uint32Array.
     * @returns Uint32Array serialization tag.
     */
    function uint32array<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike>(): ZSTypeInfo<Uint32Array<TArrayBuffer>>;
    /**
     * Indicates that data should be serialized as a BigUint64Array.
     * @returns BigUint64Array serialization tag.
     */
    function biguint64array<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike>(): ZSTypeInfo<BigUint64Array<TArrayBuffer>>;
    /**
     * Indicates that data should be serialized as a Int8Array.
     * @returns Int8Array serialization tag.
     */
    function int8array<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike>(): ZSTypeInfo<Int8Array<TArrayBuffer>>;
    /**
     * Indicates that data should be serialized as a Int16Array.
     * @returns Int16Array serialization tag.
     */
    function int16array<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike>(): ZSTypeInfo<Int16Array<TArrayBuffer>>;
    /**
     * Indicates that data should be serialized as a Int32Array.
     * @returns Int32Array serialization tag.
     */
    function int32array<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike>(): ZSTypeInfo<Int32Array<TArrayBuffer>>;
    /**
     * Indicates that data should be serialized as a BigInt64Array.
     * @returns BigInt64Array serialization tag.
     */
    function bigint64array<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike>(): ZSTypeInfo<BigInt64Array<TArrayBuffer>>;
    /**
     * Indicates that data should be serialized as a Float32Array.
     * @returns Float32Array serialization tag.
     */
    function float32array<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike>(): ZSTypeInfo<Float32Array<TArrayBuffer>>;
    /**
     * Indicates that data should be serialized as Float64Array.
     * @returns Float64Array serialization tag.
     */
    function float64array<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike>(): ZSTypeInfo<Float64Array<TArrayBuffer>>;
    /**
     * Indicates that data should be deserialized as an object.
     * @returns Object serialization tag.
     */
    function object<T extends ZSerializeable>(): ZSTypeInfo<T>;
    /**
     * Indicates that data should be serialized as an array.
     * @param t An optional array element serialization tag (if omitted the default one will be used).
     * @returns Array serialization tag.
     */
    function array<T>(t?: ZSTypeInfo<EnsureSerializeable<T>>): ZSTypeInfo<EnsureSerializeable<T>[]>;
    /**
     * Indicates that data should be serialized as a map.
     * @param tKey An optional key type serialization tag (if omitted the default one will be used).
     * @param tValue An optional value type serialization tag (if omitted the default one will be used).
     * @returns Array serialization tag.
     */
    function map<K, V>(tKey?: ZSTypeInfo<EnsureSerializeable<K>>, tValue?: ZSTypeInfo<EnsureSerializeable<V>>): ZSTypeInfo<Map<EnsureSerializeable<K>, EnsureSerializeable<V>>>;
}
export declare class ZBytesDeserializer {
    private static readonly LEB128_CONTINUATION_MASK;
    private buffer_;
    private idx_;
    /**
     * new function to create a ZBytesDeserializer
     * @param data payload to deserialize.
     * @returns ZBytesSerializer
     */
    constructor(data: ZBytes | Uint8Array);
    private readSlice;
    private readByte;
    private peekByte;
    /**
     * Reads length of the sequence previously written by {@link ZBytesSerializer.writeSequenceLength} and advances the reading position.
     * @returns Number of sequence elements.
     */
    readSequenceLength(): number;
    /**
     * Deserializes next portion of data as string and advances the reading position.
     */
    deserializeString(): string;
    /**
     * Deserializes next portion of data as Uint8Array and advances the reading position.
     */
    deserializeUint8Array(): Uint8Array;
    /**
     * Deserializes next portion of data as Uint16Array and advances the reading position.
     */
    deserializeUint16Array(): Uint16Array;
    /**
     * Deserializes next portion of data as Uint32Array and advances the reading position.
     */
    deserializeUint32Array(): Uint32Array;
    /**
     * Deserializes next portion of data as BigUint64Array and advances the reading position.
     */
    deserializeBiguint64Array(): BigUint64Array;
    /**
     * Deserializes next portion of data as Int8Array and advances the reading position.
     */
    deserializeInt8Array(): Int8Array;
    /**
     * Deserializes next portion of data as Int16Array and advances the reading position.
     */
    deserializeInt16Array(): Int16Array;
    /**
     * Deserializes next portion of data as Int32Array and advances the reading position.
     */
    deserializeInt32Array(): Int32Array;
    /**
     * Deserializes next portion of data as BigInt64Array and advances the reading position.
     */
    deserializeBigint64Array(): BigInt64Array;
    /**
     * Deserializes next portion of data as Float32Array and advances the reading position.
     */
    deserializeFloat32Array(): Float32Array;
    /**
     * Deserializes next portion of data as Float64Array and advances the reading position.
     */
    deserializeFloat64Array(): Float64Array;
    /**
     * Deserializes next portion of data (serialized as 64 bit signed integer) as bigint and advances the reading position.
     */
    deserializeBigintInt64(): bigint;
    /**
     * Deserializes next portion of data (serialized as 64 bit unsigned integer) as bigint and advances the reading position.
     */
    deserializeBigintUint64(): bigint;
    /**
     * Deserializes next portion of data (serialized as 64 bit floating point number) as number and advances the reading position.
     */
    deserializeNumberFloat64(): number;
    /**
     * Deserializes next portion of data (serialized as 32 bit floating point number) as number and advances the reading position.
     */
    deserializeNumberFloat32(): number;
    /**
     * Deserializes next portion of data (serialized as 64 bit signed integer) as number and advances the reading position.
     * Throws an error if the value exceeds the safe integer range (-2^53 to 2^53).
     */
    deserializeNumberInt64(): number;
    /**
     * Deserializes next portion of data (serialized as 64 bit unsigned integer) as number and advances the reading position.
     * Throws an error if the value exceeds the safe integer range (-2^53 to 2^53).
     */
    deserializeNumberUint64(): number;
    /**
     * Deserializes next portion of data (serialized as 32 bit signed integer) as number and advances the reading position.
     */
    deserializeNumberInt32(): number;
    /**
     * Deserializes next portion of data (serialized as 32 bit unsigned integer) as number and advances the reading position.
     */
    deserializeNumberUint32(): number;
    /**
     * Deserializes next portion of data (serialized as 16 bit signed integer) as number and advances the reading position.
     */
    deserializeNumberInt16(): number;
    /**
     * Deserializes next portion of data (serialized as 16 bit unsigned integer) as number and advances the reading position.
     */
    deserializeNumberUint16(): number;
    /**
     * Deserializes next portion of data (serialized as 8 bit signed integer) as number and advances the reading position.
     */
    deserializeNumberInt8(): number;
    /**
     * Deserializes next portion of data (serialized as 8 bit unsigned integer) as number and advances the reading position.
     */
    deserializeNumberUint8(): number;
    /**
     * Deserializes next portion of data as a boolean and advances the reading position.
     */
    deserializeBoolean(): boolean;
    /**
     * Deserializes next portion of data as an array of specified type and advances the reading position.
     * @param p Deserialization tag for array element.
     */
    deserializeArray<T>(p: ZDTypeInfo<T>): T[];
    /**
     * Deserializes next portion of data as a map of specified key and value types and advances the reading position.
     * @param pKey Deserialization tag for map key.
     * @param pValue Deserialization tag for map value.
     */
    deserializeMap<K, V>(pKey: ZDTypeInfo<K>, pValue: ZDTypeInfo<V>): Map<K, V>;
    /**
     * Deserializes next portion of data as an object of specified type and advances the reading position.
     * @param create A new function to create an object instance where data will be deserialized.
     */
    deserializeObject<T extends ZDeserializeable>(create: new () => T): T;
    /**
     * Deserializes next portion of data into any supported type and advances the reading position.
     * Supported types are:
     *   - built-in types: number, bigint, string, boolean,
     *   - types that implement ZDeserializeable interface,
     *   - TypedArrays,
     *   - arrays and maps of supported types.
     * @param p Deserialization tag.
     * @returns Deserialized value.
     */
    deserialize<T>(p: ZDTypeInfo<T>): T;
    /**
     * @returns True if all payload bytes were used, false otherwise.
     */
    isDone(): boolean;
}
/**
 * Serializes any supported type.
 * Supported types are:
 *   - built-in types: number, bigint, string, boolean,
 *   - TypedArrays,
 *   - arrays and maps of supported types.
 * @param val Value to serialize.
 * @param t An optional serialization tag (if ommited, the default one will be used).
 * @returns Payload.
 */
export declare function zserialize<T>(val: EnsureSerializeable<T>, t?: ZSTypeInfo<EnsureSerializeable<T>>): ZBytes;
/**
 * Deserializes payload into any supported type and advances the reading position.
 * Supported types are:
 *   - built-in types: number, bigint, string, boolean,
 *   - types that implement ZDeserializeable interface,
 *   - TypedArrays,
 *   - arrays and maps of supported types.
 * @param t Deserialization tag.
 * @param data Payload to deserialize.
 * @returns Deserialized value.
 */
export declare function zdeserialize<T>(t: ZDTypeInfo<T>, data: ZBytes): T;
export {};
