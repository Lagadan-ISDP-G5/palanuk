//
// Copyright (c) 2025 ZettaScale Technology
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0
// which is available at https://www.apache.org/licenses/LICENSE-2.0.
//
// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
//
// Contributors:
//   ZettaScale Zenoh Team, <zenoh@zettascale.tech>
//
import * as leb from "@thi.ng/leb128";
import { ZBytes } from '../z_bytes.js';
/**
 * Browser-compatible type checking functions
 */
function isUint8Array(arr) {
    return arr instanceof Uint8Array;
}
function isUint16Array(arr) {
    return arr instanceof Uint16Array;
}
function isUint32Array(arr) {
    return arr instanceof Uint32Array;
}
function isBigUint64Array(arr) {
    return arr instanceof BigUint64Array;
}
function isInt8Array(arr) {
    return arr instanceof Int8Array;
}
function isInt16Array(arr) {
    return arr instanceof Int16Array;
}
function isInt32Array(arr) {
    return arr instanceof Int32Array;
}
function isBigInt64Array(arr) {
    return arr instanceof BigInt64Array;
}
function isFloat32Array(arr) {
    return arr instanceof Float32Array;
}
function isFloat64Array(arr) {
    return arr instanceof Float64Array;
}
const isLittleEndian = ((new Uint32Array((new Uint8Array([1, 2, 3, 4])).buffer))[0] === 0x04030201);
function isSerializeable(s) {
    return s.serializeWithZSerializer !== undefined;
}
/**
 * A Zenoh serializer.
 * Provides functionality for tuple-like serialization.
 */
export class ZBytesSerializer {
    static DEFAULT_BUFFER_SIZE = 256;
    static MAX_SEQUENCE_LENGTH_TO_FIT_IN_SINGLE_BYTE = 127;
    buffer;
    bufferLen;
    data;
    len;
    resetBuffer(size) {
        if (size < ZBytesSerializer.DEFAULT_BUFFER_SIZE) {
            size = ZBytesSerializer.DEFAULT_BUFFER_SIZE;
        }
        this.buffer = new Uint8Array(size);
        this.bufferLen = 0;
    }
    ensureBuffer(size) {
        if (this.bufferLen + size >= this.buffer.length) {
            this.resetBuffer(size);
        }
        this.bufferLen += size;
        return this.buffer.subarray(this.bufferLen - size, this.bufferLen);
    }
    /**
     * new function to create a ZBytesSerializer.
     *
     * @returns ZBytesSerializer
     */
    constructor() {
        this.data = new Array;
        this.len = 0;
        this.buffer = new Uint8Array(ZBytesSerializer.DEFAULT_BUFFER_SIZE);
        this.bufferLen = 0;
    }
    append(buf) {
        this.data.push(buf);
        this.len += buf.length;
    }
    /**
     * Serializes length of the sequence. Can be used when defining serialization for custom containers.
     */
    writeSequenceLength(len) {
        if (len <= ZBytesSerializer.MAX_SEQUENCE_LENGTH_TO_FIT_IN_SINGLE_BYTE) {
            this.serializeNumberUint8(len);
            return;
        }
        let a = this.ensureBuffer(10);
        let sz = leb.encodeULEB128Into(a, len);
        a = a.subarray(0, sz);
        this.bufferLen -= (10 - sz);
        this.append(a);
    }
    /**
     * Serializes a utf-8 encoded string.
     */
    serializeString(val) {
        if (val.length == 0) {
            this.writeSequenceLength(0);
        }
        else {
            const encoder = new TextEncoder();
            const encoded = encoder.encode(val);
            this.writeSequenceLength(encoded.length);
            this.append(encoded);
        }
    }
    /**
     * Serializes a Uint8Array.
     */
    serializeUint8Array(val) {
        this.writeSequenceLength(val.length);
        this.append(val);
    }
    /**
     * Serializes a Uint16Array.
     */
    serializeUint16Array(val) {
        this.writeSequenceLength(val.length);
        if (isLittleEndian) {
            this.append(new Uint8Array(val.buffer));
        }
        else {
            val.forEach((element) => this.serializeNumberUint16(element));
        }
    }
    /**
     * Serializes a Uint32Array.
     */
    serializeUint32Array(val) {
        this.writeSequenceLength(val.length);
        if (isLittleEndian) {
            this.append(new Uint8Array(val.buffer));
        }
        else {
            val.forEach((element) => this.serializeNumberUint32(element));
        }
    }
    /**
     * Serializes a BigUint64Array.
     */
    serializeBiguint64Array(val) {
        this.writeSequenceLength(val.length);
        if (isLittleEndian) {
            this.append(new Uint8Array(val.buffer));
        }
        else {
            val.forEach((element) => this.serializeBigintUint64(element));
        }
    }
    /**
     * Serializes a Int8Array.
     */
    serializeInt8Array(val) {
        this.writeSequenceLength(val.length);
        this.append(new Uint8Array(val.buffer));
    }
    /**
     * Serializes a Int16Array.
     */
    serializeInt16Array(val) {
        this.writeSequenceLength(val.length);
        if (isLittleEndian) {
            this.append(new Uint8Array(val.buffer));
        }
        else {
            val.forEach((element) => this.serializeNumberInt16(element));
        }
    }
    /**
     * Serializes a Int32Array.
     */
    serializeInt32Array(val) {
        this.writeSequenceLength(val.length);
        if (isLittleEndian) {
            this.append(new Uint8Array(val.buffer));
        }
        else {
            val.forEach((element) => this.serializeNumberInt32(element));
        }
    }
    /**
     * Serializes a BigInt64Array.
     */
    serializeBigint64Array(val) {
        this.writeSequenceLength(val.length);
        if (isLittleEndian) {
            this.append(new Uint8Array(val.buffer));
        }
        else {
            val.forEach((element) => this.serializeBigintInt64(element));
        }
    }
    /**
     * Serializes a Float32Array.
     */
    serializeFloat32Array(val) {
        this.writeSequenceLength(val.length);
        if (isLittleEndian) {
            this.append(new Uint8Array(val.buffer));
        }
        else {
            val.forEach((element) => this.serializeNumberFloat32(element));
        }
    }
    /**
     * Serializes a Float64Array.
     */
    serializeFloat64Array(val) {
        this.writeSequenceLength(val.length);
        if (isLittleEndian) {
            this.append(new Uint8Array(val.buffer));
        }
        else {
            val.forEach((element) => this.serializeNumberFloat64(element));
        }
    }
    /**
     * Serializes bigint as 64 bit signed integer.
     */
    serializeBigintInt64(val) {
        let data = this.ensureBuffer(8);
        let view = new DataView(data.buffer, data.byteOffset, data.byteLength);
        view.setBigInt64(0, val, true);
        this.append(data);
    }
    /**
     * Serializes bigint as 64 bit unsigned integer.
     */
    serializeBigintUint64(val) {
        let data = this.ensureBuffer(8);
        let view = new DataView(data.buffer, data.byteOffset, data.byteLength);
        view.setBigUint64(0, val, true);
        this.append(data);
    }
    /**
     * Serializes number as 64 bit floating point number.
     */
    serializeNumberFloat64(val) {
        let data = this.ensureBuffer(8);
        let view = new DataView(data.buffer, data.byteOffset, data.byteLength);
        view.setFloat64(0, val, true);
        this.append(data);
    }
    /**
     * Serializes number as 32 bit floating point number.
     */
    serializeNumberFloat32(val) {
        let data = this.ensureBuffer(4);
        let view = new DataView(data.buffer, data.byteOffset, data.byteLength);
        view.setFloat32(0, val, true);
        this.append(data);
    }
    /**
     * Serializes number as 64 bit integer.
     */
    serializeNumberInt64(val) {
        let bigintVal = BigInt(val);
        this.serializeBigintInt64(bigintVal);
    }
    /**
     * Serializes number as 64 bit unsigned integer.
     */
    serializeNumberUint64(val) {
        let bigintVal = BigInt(val);
        this.serializeBigintUint64(bigintVal);
    }
    /**
     * Serializes number as 32 bit integer.
     */
    serializeNumberInt32(val) {
        let data = this.ensureBuffer(4);
        let view = new DataView(data.buffer, data.byteOffset, data.byteLength);
        view.setInt32(0, val, true);
        this.append(data);
    }
    /**
     * Serializes number as 32 bit unsigned integer.
     */
    serializeNumberUint32(val) {
        let data = this.ensureBuffer(4);
        let view = new DataView(data.buffer, data.byteOffset, data.byteLength);
        view.setUint32(0, val, true);
        this.append(data);
    }
    /**
     * Serializes number as 16 bit integer.
     */
    serializeNumberInt16(val) {
        let data = this.ensureBuffer(2);
        let view = new DataView(data.buffer, data.byteOffset, data.byteLength);
        view.setInt16(0, val, true);
        this.append(data);
    }
    /**
     * Serializes number as 16 bit unsigned integer.
     */
    serializeNumberUint16(val) {
        let data = this.ensureBuffer(2);
        let view = new DataView(data.buffer, data.byteOffset, data.byteLength);
        view.setUint16(0, val, true);
        this.append(data);
    }
    /**
     * Serializes number as 8 bit integer.
     */
    serializeNumberInt8(val) {
        let data = this.ensureBuffer(1);
        let view = new DataView(data.buffer, data.byteOffset, data.byteLength);
        view.setInt8(0, val);
        this.append(data);
    }
    /**
     * Serializes number as 8 bit unsigned integer.
     */
    serializeNumberUint8(val) {
        let data = this.ensureBuffer(1);
        data[0] = val;
        this.append(data);
    }
    /**
     * Serializes boolean.
     */
    serializeBoolean(val) {
        this.serializeNumberUint8(val === true ? 1 : 0);
    }
    /**
     * Serializes an array.
     */
    serializeArray(val, t) {
        this.writeSequenceLength(val.length);
        if (val.length > 0 && t === undefined) {
            t = this.getDefaultSerializationTag(val[0]);
        }
        val.forEach((element) => t.serialize(this, element));
    }
    /**
     * Serializes a map.
     */
    serializeMap(m, tKey, tValue) {
        this.writeSequenceLength(m.size);
        if (m.size > 0) {
            let val = m.entries().next();
            if (val !== undefined) {
                let value = val.value;
                if (value !== undefined) {
                    tKey ??= this.getDefaultSerializationTag(value[0]);
                    tValue ??= this.getDefaultSerializationTag(value[1]);
                }
            }
        }
        m.forEach((v, k) => {
            tKey.serialize(this, k);
            tValue.serialize(this, v);
        });
    }
    getDefaultSerializationTag(data) {
        if (isSerializeable(data)) {
            return ZS.object();
        }
        else if (typeof data == "number") {
            return ZS.number();
        }
        else if (typeof data == "bigint") {
            return ZS.bigint();
        }
        else if (typeof data == "string") {
            return ZS.string();
        }
        else if (typeof data == "boolean") {
            return ZS.boolean();
        }
        else if (isUint8Array(data)) {
            return ZS.uint8array();
        }
        else if (isUint16Array(data)) {
            return ZS.uint16array();
        }
        else if (isUint32Array(data)) {
            return ZS.uint32array();
        }
        else if (isBigUint64Array(data)) {
            return ZS.biguint64array();
        }
        else if (isInt8Array(data)) {
            return ZS.int8array();
        }
        else if (isInt16Array(data)) {
            return ZS.int16array();
        }
        else if (isInt32Array(data)) {
            return ZS.int32array();
        }
        else if (isBigInt64Array(data)) {
            return ZS.bigint64array();
        }
        else if (isFloat32Array(data)) {
            return ZS.float32array();
        }
        else if (isFloat64Array(data)) {
            return ZS.float64array();
        }
        else if (Array.isArray(data)) {
            let t = undefined;
            if (data.length > 0) {
                t = this.getDefaultSerializationTag(data[0]);
            }
            return ZS.array(t);
        }
        else if (data instanceof Map) {
            let tKey = undefined;
            let tValue = undefined;
            let val = data.entries().next();
            if (val !== undefined) {
                let value = val.value;
                if (value !== undefined) {
                    tKey = this.getDefaultSerializationTag(value[0]);
                    tValue = this.getDefaultSerializationTag(value[1]);
                }
            }
            return ZS.map(tKey, tValue);
        }
        else { // should never happen
            throw new Error(`Non-ZSerializeable type`);
        }
    }
    /**
     * Serializes any supported type and append it to existing serialized payload.
     * Supported types are:
     *   - built-in types: number, bigint, string, boolean,
     *   - TypedArrays,
     *   - arrays and maps of supported types.
     * @param val Value to serialize.
     * @param t An optional serialization tag (if ommited, the default one will be used).
     */
    serialize(val, t) {
        if (t === undefined) {
            this.getDefaultSerializationTag(val).serialize(this, val);
        }
        else {
            t.serialize(this, val);
        }
    }
    /**
     * Extracts ZBytes from ZBytesSerializer
     *
     * @returns ZBytes
     */
    finish() {
        const out = new ZBytes(this.toBytes());
        this.data = new Array();
        this.len = 0;
        this.bufferLen = 0;
        return out;
    }
    /**
    * Extracts currently serialized bytes.
    *
    * @returns ZBytes
    */
    toBytes() {
        if (this.data.length == 0) {
            return new Uint8Array(0);
        }
        else if (this.data.length == 1) {
            return this.data[0];
        }
        else {
            let b = new Uint8Array(this.len);
            let offset = 0;
            for (let a of this.data) {
                b.set(a, offset);
                offset += a.length;
            }
            return b;
        }
    }
}
/**
 * Format for `number` type serialization/deserialzation.
 */
export var NumberFormat;
(function (NumberFormat) {
    NumberFormat[NumberFormat["Float64"] = 1] = "Float64";
    NumberFormat[NumberFormat["Float32"] = 2] = "Float32";
    NumberFormat[NumberFormat["Int64"] = 3] = "Int64";
    NumberFormat[NumberFormat["Uint64"] = 4] = "Uint64";
    NumberFormat[NumberFormat["Int32"] = 5] = "Int32";
    NumberFormat[NumberFormat["Uint32"] = 6] = "Uint32";
    NumberFormat[NumberFormat["Int16"] = 7] = "Int16";
    NumberFormat[NumberFormat["Uint16"] = 8] = "Uint16";
    NumberFormat[NumberFormat["Int8"] = 9] = "Int8";
    NumberFormat[NumberFormat["Uint8"] = 10] = "Uint8";
})(NumberFormat || (NumberFormat = {}));
/**
 * Format for `bigint` type serialization/deserialzation.
 */
export var BigIntFormat;
(function (BigIntFormat) {
    BigIntFormat[BigIntFormat["Int64"] = 1] = "Int64";
    BigIntFormat[BigIntFormat["Uint64"] = 2] = "Uint64";
})(BigIntFormat || (BigIntFormat = {}));
class ZDTypeInfo {
    deserialize_;
    constructor(deserialize_) {
        this.deserialize_ = deserialize_;
    }
    /** @internal */
    deserialize(deserializer) {
        return this.deserialize_(deserializer);
    }
}
class ZSTypeInfo {
    serialize_;
    constructor(serialize_) {
        this.serialize_ = serialize_;
    }
    /** @internal */
    serialize(serializer, val) {
        this.serialize_(serializer, val);
    }
}
export var ZD;
(function (ZD) {
    /**
     * Indicates that value should be deserialized as a number in specified format.
     * @returns Number deserialization tag.
     */
    function number(format = NumberFormat.Float64) {
        switch (format) {
            case NumberFormat.Float64:
                return new ZDTypeInfo((z) => { return z.deserializeNumberFloat64(); });
            case NumberFormat.Float32:
                return new ZDTypeInfo((z) => { return z.deserializeNumberFloat32(); });
            case NumberFormat.Int64:
                return new ZDTypeInfo((z) => { return z.deserializeNumberInt64(); });
            case NumberFormat.Uint64:
                return new ZDTypeInfo((z) => { return z.deserializeNumberUint64(); });
            case NumberFormat.Int32:
                return new ZDTypeInfo((z) => { return z.deserializeNumberInt32(); });
            case NumberFormat.Uint32:
                return new ZDTypeInfo((z) => { return z.deserializeNumberUint32(); });
            case NumberFormat.Int16:
                return new ZDTypeInfo((z) => { return z.deserializeNumberInt16(); });
            case NumberFormat.Uint16:
                return new ZDTypeInfo((z) => { return z.deserializeNumberUint16(); });
            case NumberFormat.Int8:
                return new ZDTypeInfo((z) => { return z.deserializeNumberInt8(); });
            case NumberFormat.Uint8:
                return new ZDTypeInfo((z) => { return z.deserializeNumberUint8(); });
        }
    }
    ZD.number = number;
    /**
     * Indicates that data should be deserialized as a bigint in specified format.
     * @returns Bigint deserialization tag.
     */
    function bigint(format = BigIntFormat.Int64) {
        switch (format) {
            case BigIntFormat.Int64:
                return new ZDTypeInfo((z) => { return z.deserializeBigintInt64(); });
            case BigIntFormat.Uint64:
                return new ZDTypeInfo((z) => { return z.deserializeBigintUint64(); });
        }
    }
    ZD.bigint = bigint;
    /**
     * Indicates that data should be deserialized as a string.
     * @returns String deserialization tag.
     */
    function string() {
        return new ZDTypeInfo((z) => { return z.deserializeString(); });
    }
    ZD.string = string;
    /**
     * Indicates that data should be deserialized as a boolean.
     * @returns Boolean deserialization tag.
     */
    function boolean() {
        return new ZDTypeInfo((z) => { return z.deserializeBoolean(); });
    }
    ZD.boolean = boolean;
    /**
     * Indicates that data should be deserialized as a Uint8Array.
     * @returns Uint8Array deserialization tag.
     */
    function uint8array() {
        return new ZDTypeInfo((z) => { return z.deserializeUint8Array(); });
    }
    ZD.uint8array = uint8array;
    /**
     * Indicates that data should be deserialized as a Uint16Array.
     * @returns Uint16Array deserialization tag.
     */
    function uint16array() {
        return new ZDTypeInfo((z) => { return z.deserializeUint16Array(); });
    }
    ZD.uint16array = uint16array;
    /**
     * Indicates that data should be deserialized as a Uint32Array.
     * @returns Uint32Array deserialization tag.
     */
    function uint32array() {
        return new ZDTypeInfo((z) => { return z.deserializeUint32Array(); });
    }
    ZD.uint32array = uint32array;
    /**
     * Indicates that data should be deserialized as a BigUint64Array.
     * @returns BigUint64Array deserialization tag.
     */
    function biguint64array() {
        return new ZDTypeInfo((z) => { return z.deserializeBiguint64Array(); });
    }
    ZD.biguint64array = biguint64array;
    /**
     * Indicates that data should be deserialized as a Int8Array.
     * @returns Int8Array deserialization tag.
     */
    function int8array() {
        return new ZDTypeInfo((z) => { return z.deserializeInt8Array(); });
    }
    ZD.int8array = int8array;
    /**
     * Indicates that data should be deserialized as a Int16Array.
     * @returns Int16Array deserialization tag.
     */
    function int16array() {
        return new ZDTypeInfo((z) => { return z.deserializeInt16Array(); });
    }
    ZD.int16array = int16array;
    /**
     * Indicates that data should be deserialized as a Int32Array.
     * @returns Int32Array deserialization tag.
     */
    function int32array() {
        return new ZDTypeInfo((z) => { return z.deserializeInt32Array(); });
    }
    ZD.int32array = int32array;
    /**
     * Indicates that data should be deserialized as a BigInt64Array.
     * @returns BigInt64Array deserialization tag.
     */
    function bigint64array() {
        return new ZDTypeInfo((z) => { return z.deserializeBigint64Array(); });
    }
    ZD.bigint64array = bigint64array;
    /**
     * Indicates that data should be deserialized as a Float32Array.
     * @returns Float32Array deserialization tag.
     */
    function float32array() {
        return new ZDTypeInfo((z) => { return z.deserializeFloat32Array(); });
    }
    ZD.float32array = float32array;
    /**
     * Indicates that data should be deserialized as a Float64Array.
     * @returns Float64Array deserialization tag.
     */
    function float64array() {
        return new ZDTypeInfo((z) => { return z.deserializeFloat64Array(); });
    }
    ZD.float64array = float64array;
    /**
     * Indicates that data should be deserialized as an object.
     * @param create A new function to create an object instance where data will be deserialized.
     * @returns Object deserialization tag.
     */
    function object(create) {
        return new ZDTypeInfo((z) => { return z.deserializeObject(create); });
    }
    ZD.object = object;
    /**
     * Indicates that data should be deserialized as an object.
     * @param create A function to create an object instance from deserializer.
     * @returns Object deserialization tag.
     */
    function objectStatic(create) {
        return new ZDTypeInfo((z) => { return create(z); });
    }
    ZD.objectStatic = objectStatic;
    /**
     * Indicates that data should be deserialized as an array.
     * @param t An array element deserialization tag.
     * @returns Array deserialization tag.
     */
    function array(t) {
        return new ZDTypeInfo((z) => { return z.deserializeArray(t); });
    }
    ZD.array = array;
    /**
     * Indicates that data should be deserialized as a map.
     * @param tKey A key type deserialization tag.
     * @param tValue A value type deserialization tag.
     * @returns Array deserialization tag.
     */
    function map(tKey, tValue) {
        return new ZDTypeInfo((z) => { return z.deserializeMap(tKey, tValue); });
    }
    ZD.map = map;
})(ZD || (ZD = {}));
export var ZS;
(function (ZS) {
    /**
     * Indicates that value should be serialized as a number in specified format.
     * @returns Number serialization tag.
     */
    function number(format = NumberFormat.Float64) {
        switch (format) {
            case NumberFormat.Float64:
                return new ZSTypeInfo((z, val) => { z.serializeNumberFloat64(val); });
            case NumberFormat.Float32:
                return new ZSTypeInfo((z, val) => { z.serializeNumberFloat32(val); });
            case NumberFormat.Int64:
                return new ZSTypeInfo((z, val) => { z.serializeNumberInt64(val); });
            case NumberFormat.Uint64:
                return new ZSTypeInfo((z, val) => { z.serializeNumberUint64(val); });
            case NumberFormat.Int32:
                return new ZSTypeInfo((z, val) => { z.serializeNumberInt32(val); });
            case NumberFormat.Uint32:
                return new ZSTypeInfo((z, val) => { z.serializeNumberUint32(val); });
            case NumberFormat.Int16:
                return new ZSTypeInfo((z, val) => { z.serializeNumberInt16(val); });
            case NumberFormat.Uint16:
                return new ZSTypeInfo((z, val) => { z.serializeNumberUint16(val); });
            case NumberFormat.Int8:
                return new ZSTypeInfo((z, val) => { z.serializeNumberInt8(val); });
            case NumberFormat.Uint8:
                return new ZSTypeInfo((z, val) => { z.serializeNumberUint8(val); });
        }
    }
    ZS.number = number;
    /**
     * Indicates that data should be serialized as a bigint in specified format.
     * @returns Bigint serialization tag.
     */
    function bigint(format = BigIntFormat.Int64) {
        switch (format) {
            case BigIntFormat.Int64:
                return new ZSTypeInfo((z, val) => { z.serializeBigintInt64(val); });
            case BigIntFormat.Uint64:
                return new ZSTypeInfo((z, val) => { z.serializeBigintUint64(val); });
        }
    }
    ZS.bigint = bigint;
    /**
     * Indicates that data should be serialized as a string.
     * @returns String serialization tag.
     */
    function string() {
        return new ZSTypeInfo((z, val) => { z.serializeString(val); });
    }
    ZS.string = string;
    /**
     * Indicates that data should be serialized as a boolean.
     * @returns Boolean serialization tag.
     */
    function boolean() {
        return new ZSTypeInfo((z, val) => { z.serializeBoolean(val); });
    }
    ZS.boolean = boolean;
    /**
     * Indicates that data should be serialized as a Uint8Array.
     * @returns Uint8Array serialization tag.
     */
    function uint8array() {
        return new ZSTypeInfo((z, val) => { z.serializeUint8Array(val); });
    }
    ZS.uint8array = uint8array;
    /**
     * Indicates that data should be serialized as a Uint16Array.
     * @returns Uint16Array serialization tag.
     */
    function uint16array() {
        return new ZSTypeInfo((z, val) => { z.serializeUint16Array(val); });
    }
    ZS.uint16array = uint16array;
    /**
     * Indicates that data should be serialized as a Uint32Array.
     * @returns Uint32Array serialization tag.
     */
    function uint32array() {
        return new ZSTypeInfo((z, val) => { z.serializeUint32Array(val); });
    }
    ZS.uint32array = uint32array;
    /**
     * Indicates that data should be serialized as a BigUint64Array.
     * @returns BigUint64Array serialization tag.
     */
    function biguint64array() {
        return new ZSTypeInfo((z, val) => { z.serializeBiguint64Array(val); });
    }
    ZS.biguint64array = biguint64array;
    /**
     * Indicates that data should be serialized as a Int8Array.
     * @returns Int8Array serialization tag.
     */
    function int8array() {
        return new ZSTypeInfo((z, val) => { z.serializeInt8Array(val); });
    }
    ZS.int8array = int8array;
    /**
     * Indicates that data should be serialized as a Int16Array.
     * @returns Int16Array serialization tag.
     */
    function int16array() {
        return new ZSTypeInfo((z, val) => { z.serializeInt16Array(val); });
    }
    ZS.int16array = int16array;
    /**
     * Indicates that data should be serialized as a Int32Array.
     * @returns Int32Array serialization tag.
     */
    function int32array() {
        return new ZSTypeInfo((z, val) => { z.serializeInt32Array(val); });
    }
    ZS.int32array = int32array;
    /**
     * Indicates that data should be serialized as a BigInt64Array.
     * @returns BigInt64Array serialization tag.
     */
    function bigint64array() {
        return new ZSTypeInfo((z, val) => { z.serializeBigint64Array(val); });
    }
    ZS.bigint64array = bigint64array;
    /**
     * Indicates that data should be serialized as a Float32Array.
     * @returns Float32Array serialization tag.
     */
    function float32array() {
        return new ZSTypeInfo((z, val) => { z.serializeFloat32Array(val); });
    }
    ZS.float32array = float32array;
    /**
     * Indicates that data should be serialized as Float64Array.
     * @returns Float64Array serialization tag.
     */
    function float64array() {
        return new ZSTypeInfo((z, val) => { z.serializeFloat64Array(val); });
    }
    ZS.float64array = float64array;
    /**
     * Indicates that data should be deserialized as an object.
     * @returns Object serialization tag.
     */
    function object() {
        return new ZSTypeInfo((z, val) => { val.serializeWithZSerializer(z); });
    }
    ZS.object = object;
    /**
     * Indicates that data should be serialized as an array.
     * @param t An optional array element serialization tag (if omitted the default one will be used).
     * @returns Array serialization tag.
     */
    function array(t) {
        return new ZSTypeInfo((z, val) => { z.serializeArray(val, t); });
    }
    ZS.array = array;
    /**
     * Indicates that data should be serialized as a map.
     * @param tKey An optional key type serialization tag (if omitted the default one will be used).
     * @param tValue An optional value type serialization tag (if omitted the default one will be used).
     * @returns Array serialization tag.
     */
    function map(tKey, tValue) {
        return new ZSTypeInfo((z, val) => { z.serializeMap(val, tKey, tValue); });
    }
    ZS.map = map;
})(ZS || (ZS = {}));
export class ZBytesDeserializer {
    static LEB128_CONTINUATION_MASK = 0b10000000;
    buffer_;
    idx_;
    /**
     * new function to create a ZBytesDeserializer
     * @param data payload to deserialize.
     * @returns ZBytesSerializer
     */
    constructor(data) {
        if (data instanceof ZBytes) {
            this.buffer_ = data.toBytes();
        }
        else {
            this.buffer_ = data;
        }
        this.idx_ = 0;
    }
    readSlice(len) {
        const s = this.buffer_.subarray(this.idx_, this.idx_ + len);
        if (s.length < len) {
            throw new Error(`Array index is out of bounds: ${this.idx_ + len} / ${this.buffer_.length}`);
        }
        this.idx_ += len;
        return s;
    }
    readByte() {
        if (this.idx_ >= this.buffer_.length) {
            throw new Error(`Array index is out of bounds: ${this.idx_ + 1} / ${this.buffer_.length}`);
        }
        const b = this.buffer_[this.idx_];
        this.idx_ += 1;
        return b;
    }
    peekByte() {
        return this.buffer_[this.idx_];
    }
    /**
     * Reads length of the sequence previously written by {@link ZBytesSerializer.writeSequenceLength} and advances the reading position.
     * @returns Number of sequence elements.
     */
    readSequenceLength() {
        const b = this.peekByte();
        if (b != undefined && (b & ZBytesDeserializer.LEB128_CONTINUATION_MASK) == 0) {
            this.idx_ += 1;
            return b;
        }
        let [res, bytesRead] = leb.decodeULEB128(this.buffer_, this.idx_);
        this.idx_ += bytesRead;
        if (res > Number.MAX_SAFE_INTEGER) {
            throw new Error(`Array length overflow: ${res}`);
        }
        return new Number(res).valueOf();
    }
    /**
     * Deserializes next portion of data as string and advances the reading position.
     */
    deserializeString() {
        let len = this.readSequenceLength();
        if (len == 0) {
            return "";
        }
        else {
            const decoder = new TextDecoder();
            return decoder.decode(this.readSlice(len));
        }
    }
    /**
     * Deserializes next portion of data as Uint8Array and advances the reading position.
     */
    deserializeUint8Array() {
        let len = this.readSequenceLength();
        return this.readSlice(len);
    }
    /**
     * Deserializes next portion of data as Uint16Array and advances the reading position.
     */
    deserializeUint16Array() {
        let len = this.readSequenceLength();
        if (isLittleEndian) {
            let s = this.readSlice(len * 2);
            if (s.byteOffset % 2 != 0) {
                s = s.slice();
            }
            return new Uint16Array(s.buffer, s.byteOffset, len);
        }
        else {
            let out = new Uint16Array(len);
            for (let i = 0; i < len; i++) {
                out[i] = this.deserializeNumberUint16();
            }
            return out;
        }
    }
    /**
     * Deserializes next portion of data as Uint32Array and advances the reading position.
     */
    deserializeUint32Array() {
        let len = this.readSequenceLength();
        if (isLittleEndian) {
            let s = this.readSlice(len * 4);
            if (s.byteOffset % 4 != 0) {
                s = s.slice();
            }
            return new Uint32Array(s.buffer, s.byteOffset, len);
        }
        else {
            let out = new Uint32Array(len);
            for (let i = 0; i < len; i++) {
                out[i] = this.deserializeNumberUint32();
            }
            return out;
        }
    }
    /**
     * Deserializes next portion of data as BigUint64Array and advances the reading position.
     */
    deserializeBiguint64Array() {
        let len = this.readSequenceLength();
        if (isLittleEndian) {
            let s = this.readSlice(len * 8);
            if (s.byteOffset % 8 != 0) {
                s = s.slice();
            }
            return new BigUint64Array(s.buffer, s.byteOffset, len);
        }
        else {
            let out = new BigUint64Array(len);
            for (let i = 0; i < len; i++) {
                out[i] = this.deserializeBigintUint64();
            }
            return out;
        }
    }
    /**
     * Deserializes next portion of data as Int8Array and advances the reading position.
     */
    deserializeInt8Array() {
        let len = this.readSequenceLength();
        const s = this.readSlice(len);
        return new Int8Array(s.buffer, s.byteOffset, len);
    }
    /**
     * Deserializes next portion of data as Int16Array and advances the reading position.
     */
    deserializeInt16Array() {
        let len = this.readSequenceLength();
        if (isLittleEndian) {
            let s = this.readSlice(len * 2);
            if (s.byteOffset % 2 != 0) {
                s = s.slice();
            }
            return new Int16Array(s.buffer, s.byteOffset, len);
        }
        else {
            let out = new Int16Array(len);
            for (let i = 0; i < len; i++) {
                out[i] = this.deserializeNumberInt16();
            }
            return out;
        }
    }
    /**
     * Deserializes next portion of data as Int32Array and advances the reading position.
     */
    deserializeInt32Array() {
        let len = this.readSequenceLength();
        if (isLittleEndian) {
            let s = this.readSlice(len * 4);
            if (s.byteOffset % 4 != 0) {
                s = s.slice();
            }
            return new Int32Array(s.buffer, s.byteOffset, len);
        }
        else {
            let out = new Int32Array(len);
            for (let i = 0; i < len; i++) {
                out[i] = this.deserializeNumberInt32();
            }
            return out;
        }
    }
    /**
     * Deserializes next portion of data as BigInt64Array and advances the reading position.
     */
    deserializeBigint64Array() {
        let len = this.readSequenceLength();
        if (isLittleEndian) {
            let s = this.readSlice(len * 8);
            if (s.byteOffset % 8 != 0) {
                s = s.slice();
            }
            return new BigInt64Array(s.buffer, s.byteOffset, len);
        }
        else {
            let out = new BigInt64Array(len);
            for (let i = 0; i < len; i++) {
                out[i] = this.deserializeBigintInt64();
            }
            return out;
        }
    }
    /**
     * Deserializes next portion of data as Float32Array and advances the reading position.
     */
    deserializeFloat32Array() {
        let len = this.readSequenceLength();
        if (isLittleEndian) {
            let s = this.readSlice(len * 4);
            if (s.byteOffset % 4 != 0) {
                s = s.slice();
            }
            return new Float32Array(s.buffer, s.byteOffset, len);
        }
        else {
            let out = new Float32Array(len);
            for (let i = 0; i < len; i++) {
                out[i] = this.deserializeNumberFloat32();
            }
            return out;
        }
    }
    /**
     * Deserializes next portion of data as Float64Array and advances the reading position.
     */
    deserializeFloat64Array() {
        let len = this.readSequenceLength();
        if (isLittleEndian) {
            let s = this.readSlice(len * 8);
            if (s.byteOffset % 8 != 0) {
                s = s.slice();
            }
            return new Float64Array(s.buffer, s.byteOffset, len);
        }
        else {
            let out = new Float64Array(len);
            for (let i = 0; i < len; i++) {
                out[i] = this.deserializeNumberFloat64();
            }
            return out;
        }
    }
    /**
     * Deserializes next portion of data (serialized as 64 bit signed integer) as bigint and advances the reading position.
     */
    deserializeBigintInt64() {
        let data = this.readSlice(8);
        let view = new DataView(data.buffer, data.byteOffset, data.byteLength);
        return view.getBigInt64(0, true);
    }
    /**
     * Deserializes next portion of data (serialized as 64 bit unsigned integer) as bigint and advances the reading position.
     */
    deserializeBigintUint64() {
        let data = this.readSlice(8);
        let view = new DataView(data.buffer, data.byteOffset, data.byteLength);
        return view.getBigUint64(0, true);
    }
    /**
     * Deserializes next portion of data (serialized as 64 bit floating point number) as number and advances the reading position.
     */
    deserializeNumberFloat64() {
        let data = this.readSlice(8);
        let view = new DataView(data.buffer, data.byteOffset, data.byteLength);
        return view.getFloat64(0, true);
    }
    /**
     * Deserializes next portion of data (serialized as 32 bit floating point number) as number and advances the reading position.
     */
    deserializeNumberFloat32() {
        let data = this.readSlice(4);
        let view = new DataView(data.buffer, data.byteOffset, data.byteLength);
        return view.getFloat32(0, true);
    }
    /**
     * Deserializes next portion of data (serialized as 64 bit signed integer) as number and advances the reading position.
     * Throws an error if the value exceeds the safe integer range (-2^53 to 2^53).
     */
    deserializeNumberInt64() {
        let bigint = this.deserializeBigintInt64();
        if (bigint > Number.MAX_SAFE_INTEGER || bigint < Number.MIN_SAFE_INTEGER) {
            throw new Error(`Integer value ${bigint} exceeds the safe range for JavaScript numbers`);
        }
        return Number(bigint);
    }
    /**
     * Deserializes next portion of data (serialized as 64 bit unsigned integer) as number and advances the reading position.
     * Throws an error if the value exceeds the safe integer range (-2^53 to 2^53).
     */
    deserializeNumberUint64() {
        let bigint = this.deserializeBigintUint64();
        if (bigint > Number.MAX_SAFE_INTEGER) {
            throw new Error(`Integer value ${bigint} exceeds the safe range for JavaScript numbers`);
        }
        return Number(bigint);
    }
    /**
     * Deserializes next portion of data (serialized as 32 bit signed integer) as number and advances the reading position.
     */
    deserializeNumberInt32() {
        let data = this.readSlice(4);
        let view = new DataView(data.buffer, data.byteOffset, data.byteLength);
        return view.getInt32(0, true);
    }
    /**
     * Deserializes next portion of data (serialized as 32 bit unsigned integer) as number and advances the reading position.
     */
    deserializeNumberUint32() {
        let data = this.readSlice(4);
        let view = new DataView(data.buffer, data.byteOffset, data.byteLength);
        return view.getUint32(0, true);
    }
    /**
     * Deserializes next portion of data (serialized as 16 bit signed integer) as number and advances the reading position.
     */
    deserializeNumberInt16() {
        let data = this.readSlice(2);
        let view = new DataView(data.buffer, data.byteOffset, data.byteLength);
        return view.getInt16(0, true);
    }
    /**
     * Deserializes next portion of data (serialized as 16 bit unsigned integer) as number and advances the reading position.
     */
    deserializeNumberUint16() {
        let data = this.readSlice(2);
        let view = new DataView(data.buffer, data.byteOffset, data.byteLength);
        return view.getUint16(0, true);
    }
    /**
     * Deserializes next portion of data (serialized as 8 bit signed integer) as number and advances the reading position.
     */
    deserializeNumberInt8() {
        let data = this.readSlice(1);
        let view = new DataView(data.buffer, data.byteOffset, data.byteLength);
        return view.getInt8(0);
    }
    /**
     * Deserializes next portion of data (serialized as 8 bit unsigned integer) as number and advances the reading position.
     */
    deserializeNumberUint8() {
        return this.readByte();
    }
    /**
     * Deserializes next portion of data as a boolean and advances the reading position.
     */
    deserializeBoolean() {
        const res = this.readByte();
        if (res == 1) {
            return true;
        }
        else if (res == 0) {
            return false;
        }
        else {
            throw new Error(`Unexpected boolean value: ${res}`);
        }
    }
    /**
     * Deserializes next portion of data as an array of specified type and advances the reading position.
     * @param p Deserialization tag for array element.
     */
    deserializeArray(p) {
        const len = this.readSequenceLength();
        let out = new Array(len);
        for (let i = 0; i < len; i++) {
            out[i] = p.deserialize(this);
        }
        return out;
    }
    /**
     * Deserializes next portion of data as a map of specified key and value types and advances the reading position.
     * @param pKey Deserialization tag for map key.
     * @param pValue Deserialization tag for map value.
     */
    deserializeMap(pKey, pValue) {
        const len = this.readSequenceLength();
        let out = new Map();
        for (let i = 0; i < len; i++) {
            const key = pKey.deserialize(this);
            const value = pValue.deserialize(this);
            out.set(key, value);
        }
        return out;
    }
    /**
     * Deserializes next portion of data as an object of specified type and advances the reading position.
     * @param create A new function to create an object instance where data will be deserialized.
     */
    deserializeObject(create) {
        let o = new create();
        o.deserializeWithZDeserializer(this);
        return o;
    }
    /**
     * Deserializes next portion of data into any supported type and advances the reading position.
     * Supported types are:
     *   - built-in types: number, bigint, string, boolean,
     *   - types that implement ZDeserializeable interface,
     *   - TypedArrays,
     *   - arrays and maps of supported types.
     * @param p Deserialization tag.
     * @returns Deserialized value.
     */
    deserialize(p) {
        return p.deserialize(this);
    }
    /**
     * @returns True if all payload bytes were used, false otherwise.
     */
    isDone() {
        return this.buffer_.length == this.idx_;
    }
}
/**
 * Serializes any supported type.
 * Supported types are:
 *   - built-in types: number, bigint, string, boolean,
 *   - TypedArrays,
 *   - arrays and maps of supported types.
 * @param val Value to serialize.
 * @param t An optional serialization tag (if ommited, the default one will be used).
 * @returns Payload.
 */
export function zserialize(val, t) {
    const s = new ZBytesSerializer();
    s.serialize(val, t);
    return s.finish();
}
/**
 * Deserializes payload into any supported type and advances the reading position.
 * Supported types are:
 *   - built-in types: number, bigint, string, boolean,
 *   - types that implement ZDeserializeable interface,
 *   - TypedArrays,
 *   - arrays and maps of supported types.
 * @param t Deserialization tag.
 * @param data Payload to deserialize.
 * @returns Deserialized value.
 */
export function zdeserialize(t, data) {
    const d = new ZBytesDeserializer(data);
    const res = d.deserialize(t);
    if (!d.isDone()) {
        throw new Error(`Payload contains more bytes than required for deserialization`);
    }
    return res;
}
//# sourceMappingURL=serialization.js.map