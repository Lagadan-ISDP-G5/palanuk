//
// Copyright (c) 2023 ZettaScale Technology
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0
// which is available at https://www.apache.org/licenses/LICENSE-2.0.
//
// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
//
// Contributors:
//   ZettaScale Zenoh Team, <zenoh@zettascale.tech>
//
import { KeyExpr } from "./key_expr.js";
import { ZBytes } from "./z_bytes.js";
import { Liveliness } from "./liveliness.js";
import { Queryable, Selector, } from "./query.js";
import { Publisher, Subscriber } from "./pubsub.js";
import { Encoding } from "./encoding.js";
// External deps
import { Duration } from 'typed-duration';
import { FifoChannel, intoCbDropReceiver } from "./channels.js";
import { CongestionControl, ConsolidationMode, Locality, Priority, QueryTarget, Reliability, ReplyKeyExpr } from "./enums.js";
import { SessionInner, SubscriberKind } from "./session_inner.js";
import { Delete, Put, Qos, QuerySettings } from "./message.js";
import { Querier } from "./querier.js";
export const DEFAULT_QUERY_TIMEOUT_MS = 10000;
// ███████ ███████ ███████ ███████ ██  ██████  ███    ██
// ██      ██      ██      ██      ██ ██    ██ ████   ██
// ███████ █████   ███████ ███████ ██ ██    ██ ██ ██  ██
//      ██ ██           ██      ██ ██ ██    ██ ██  ██ ██
// ███████ ███████ ███████ ███████ ██  ██████  ██   ████
/**
 * Zenoh Session
 */
export class Session {
    inner;
    async [Symbol.asyncDispose]() {
        await this.close();
    }
    constructor(inner) {
        this.inner = inner;
    }
    /**
     * Creates a new Session instance
     *
     * @remarks
     *  Opens A Zenoh Session
     *
     * @param config - Config for session
     * @returns Typescript instance of a Session
     *
     */
    static async open(config) {
        let inner = await SessionInner.open(config.locator, config.messageResponseTimeoutMs);
        return new Session(inner);
    }
    /**
     * Closes a session, cleaning up the resource in Zenoh
     *
     * @returns Nothing
     */
    async close() {
        this.inner.close();
    }
    isClosed() {
        return this.inner.isClosed();
    }
    /**
     * Puts a value on the session, on a specific key expression
     *
     * @param {IntoKeyExpr} intoKeyExpr - key expression to publish to
     * @param {IntoZBytes} intoZBytes - payload to publish
     * @param {PutOptions=} putOpts - optional additional parameters to pass to delete operation
     * @returns void
     */
    async put(intoKeyExpr, intoZBytes, putOpts) {
        await this.inner.put(new Put(new KeyExpr(intoKeyExpr), new ZBytes(intoZBytes), putOpts?.encoding ? Encoding.from(putOpts.encoding) : Encoding.default(), putOpts?.attachment ? new ZBytes(putOpts.attachment) : undefined, putOpts?.timestamp, new Qos(putOpts?.priority ?? Priority.DEFAULT, putOpts?.congestionControl ?? CongestionControl.DEFAULT_PUSH, putOpts?.express ?? false, putOpts?.reliability ?? Reliability.DEFAULT, putOpts?.allowedDestination ?? Locality.DEFAULT)));
    }
    /**
     * Creates a Key Expression
     *
     * @returns KeyExpr
     */
    declareKeyexpr(intoKeyExpr) {
        return new KeyExpr(intoKeyExpr);
    }
    /**
     * Returns the Zenoh SessionInfo Object
     *
     * @returns SessionInfo
     */
    async info() {
        return await this.inner.getSessionInfo();
    }
    /**
     * Executes a Delete on a session, for a specific key expression KeyExpr
     *
     * @param {IntoKeyExpr} intoKeyExpr - something that implements intoKeyExpr
     * @param {DeleteOptions} deleteOpts - optional additional parameters to pass to delete operation
     *
     * @returns void
     */
    async delete(intoKeyExpr, deleteOpts) {
        await this.inner.delete(new Delete(new KeyExpr(intoKeyExpr), deleteOpts?.attachment ? new ZBytes(deleteOpts.attachment) : undefined, deleteOpts?.timestamp, new Qos(deleteOpts?.priority ?? Priority.DEFAULT, deleteOpts?.congestionControl ?? CongestionControl.DEFAULT_PUSH, deleteOpts?.express ?? false, deleteOpts?.reliability ?? Reliability.DEFAULT, deleteOpts?.allowedDestination ?? Locality.DEFAULT)));
    }
    /**
     * Issues a get query on a Zenoh session
     *
     * @param intoSelector - representing a KeyExpr and Parameters
     * @param {GetOptions=} getOpts - optional additional parameters to pass to get operation
     *
     * @returns Receiver
     */
    async get(intoSelector, getOpts) {
        let handler = getOpts?.handler ?? new FifoChannel(256);
        let [callback, drop, receiver] = intoCbDropReceiver(handler);
        let selector = Selector.from(intoSelector);
        let cancellationToken = getOpts?.cancellationToken;
        if (cancellationToken?.isCancelled() ?? false) {
            drop();
            return receiver;
        }
        let getId = await this.inner.get({
            keyexpr: selector.keyExpr(),
            parameters: selector.parameters().toString(),
            payload: getOpts?.payload ? new ZBytes(getOpts.payload) : undefined,
            encoding: getOpts?.encoding ? Encoding.from(getOpts.encoding) : undefined,
            attachment: getOpts?.attachment ? new ZBytes(getOpts.attachment) : undefined,
            qos: new Qos(getOpts?.priority ?? Priority.DEFAULT, getOpts?.congestionControl ?? CongestionControl.DEFAULT_REQUEST, getOpts?.express ?? false, Reliability.DEFAULT, getOpts?.allowedDestination ?? Locality.DEFAULT),
            querySettings: new QuerySettings(getOpts?.target ?? QueryTarget.DEFAULT, getOpts?.consolidation ?? ConsolidationMode.DEFAULT, getOpts?.acceptReplies ?? ReplyKeyExpr.DEFAULT),
            timeoutMs: getOpts?.timeout ? Duration.milliseconds.from(getOpts.timeout) : DEFAULT_QUERY_TIMEOUT_MS,
        }, { callback, drop });
        cancellationToken?.addCancelAction(() => this.inner.cancelQuery(getId));
        return receiver;
    }
    /**
     * Declares a new subscriber
     *
     * @remarks
     *  If a Subscriber is created with a callback, it cannot be simultaneously polled for new values
     *
     * @param {IntoKeyExpr} intoKeyExpr - the key expression to subscribe to
     * @param {SubscriberOptions} subscriberOpts - optional additional parameters to pass to subscriber declaration
     *
     * @returns Subscriber
     */
    async declareSubscriber(intoKeyExpr, subscriberOpts) {
        const handler = subscriberOpts?.handler ?? new FifoChannel(256);
        const keyexpr = new KeyExpr(intoKeyExpr);
        let [callback, drop, receiver] = intoCbDropReceiver(handler);
        const subscriberId = await this.inner.declareSubscriber({
            keyexpr,
            allowedOrigin: subscriberOpts?.allowedOrigin ?? Locality.DEFAULT
        }, { callback, drop });
        return new Subscriber(this.inner, SubscriberKind.Subscriber, subscriberId, keyexpr, receiver);
    }
    /**
     * Obtain a Liveliness struct tied to this Zenoh Session.
     *
     * @returns Liveliness
     */
    liveliness() {
        return new Liveliness(this.inner);
    }
    /**
     * Creates a new Timestamp instance
     *
     * @returns Timestamp
     */
    async newTimestamp() {
        return await this.inner.getTimestamp();
    }
    /**
    * Declares a new Queryable
    *
    * @param {IntoKeyExpr} intoKeyExpr - Queryable key expression
    * @param {QueryableOptions=} queryableOpts - Optional additional settings for a Queryable [QueryableOptions]
    *
    * @returns Queryable
    */
    async declareQueryable(intoKeyExpr, queryableOpts) {
        const keyexpr = new KeyExpr(intoKeyExpr);
        const handler = queryableOpts?.handler ?? new FifoChannel(256);
        const [callback, drop, receiver] = intoCbDropReceiver(handler);
        const queryableId = await this.inner.declareQueryable({
            keyexpr,
            complete: queryableOpts?.complete ?? false,
            allowedOrigin: queryableOpts?.allowedOrigin ?? Locality.DEFAULT,
        }, { callback, drop });
        return new Queryable(this.inner, queryableId, keyexpr, receiver);
    }
    /**
    * Declares a new Publisher
    *
    * @param {IntoKeyExpr} intoKeyExpr - Publisher's key expression
    * @param {PublisherOptions=} publisherOpts - Optional additional settings for a Publisher [PublisherOptions]
    * @returns Publisher
    */
    async declarePublisher(intoKeyExpr, publisherOpts) {
        let publisherProperties = {
            keyexpr: new KeyExpr(intoKeyExpr),
            encoding: publisherOpts?.encoding ? Encoding.from(publisherOpts.encoding) : Encoding.default(),
            qos: new Qos(publisherOpts?.priority ?? Priority.DEFAULT, publisherOpts?.congestionControl ?? CongestionControl.DEFAULT_PUSH, publisherOpts?.express ?? false, publisherOpts?.reliability ?? Reliability.DEFAULT, publisherOpts?.allowedDestination ?? Locality.DEFAULT)
        };
        const publisherId = await this.inner.declarePublisher(publisherProperties);
        return new Publisher(this.inner, publisherId, publisherProperties);
    }
    /**
    * Declares a Querier
    *
    * @param {IntoKeyExpr} intoKeyexpr - Querier's key expression
    * @param {QuerierOptions=} querierOpts - Optional additional settings for a Querier [QuerierOptions]
    * @returns Publisher
    */
    async declareQuerier(intoKeyexpr, querierOpts) {
        const properties = {
            keyexpr: new KeyExpr(intoKeyexpr),
            qos: new Qos(querierOpts?.priority ?? Priority.DEFAULT, querierOpts?.congestionControl ?? CongestionControl.DEFAULT_REQUEST, querierOpts?.express ?? false, Reliability.DEFAULT, querierOpts?.allowedDestination ?? Locality.DEFAULT),
            querySettings: new QuerySettings(querierOpts?.target ?? QueryTarget.DEFAULT, querierOpts?.consolidation ?? ConsolidationMode.DEFAULT, querierOpts?.acceptReplies ?? ReplyKeyExpr.DEFAULT),
            timeoutMs: querierOpts?.timeout ? Duration.milliseconds.from(querierOpts.timeout) : DEFAULT_QUERY_TIMEOUT_MS,
        };
        let querierId = await this.inner.declareQuerier(properties);
        return new Querier(this.inner, querierId, properties.keyexpr, properties.qos.congestionControl, properties.qos.priority, properties.querySettings.replyKeyExpr);
    }
}
/**
 *  Function to open a Zenoh session
 */
export async function open(config) {
    return await Session.open(config);
}
/**
 *  Struct to expose Info for Zenoh Session
 */
export class SessionInfo {
    zid_;
    peers_;
    routers_;
    constructor(zid_, peers_, routers_) {
        this.zid_ = zid_;
        this.peers_ = peers_;
        this.routers_ = routers_;
    }
    zid() {
        return this.zid_;
    }
    routersZid() {
        return this.routers_;
    }
    peersZid() {
        return this.peers_;
    }
}
//# sourceMappingURL=session.js.map