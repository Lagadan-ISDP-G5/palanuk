//
// Copyright (c) 2025 ZettaScale Technology
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0
// which is available at https://www.apache.org/licenses/LICENSE-2.0.
//
// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
//
// Contributors:
//   ZettaScale Zenoh Team, <zenoh@zettascale.tech>
//
// Message priority.
export var Priority;
(function (Priority) {
    Priority[Priority["REAL_TIME"] = 1] = "REAL_TIME";
    Priority[Priority["INTERACTIVE_HIGH"] = 2] = "INTERACTIVE_HIGH";
    Priority[Priority["INTERACTIVE_LOW"] = 3] = "INTERACTIVE_LOW";
    Priority[Priority["DATA_HIGH"] = 4] = "DATA_HIGH";
    Priority[Priority["DATA"] = 5] = "DATA";
    Priority[Priority["DATA_LOW"] = 6] = "DATA_LOW";
    Priority[Priority["BACKGROUND"] = 7] = "BACKGROUND";
    Priority[Priority["DEFAULT"] = 5] = "DEFAULT";
})(Priority || (Priority = {}));
// Congestion control strategy.
export var CongestionControl;
(function (CongestionControl) {
    // When transmitting a message in a node with a full queue, the node may drop the message.
    CongestionControl[CongestionControl["DROP"] = 0] = "DROP";
    // When transmitting a message in a node with a full queue, the node will wait for queue to
    // progress.
    CongestionControl[CongestionControl["BLOCK"] = 1] = "BLOCK";
    CongestionControl[CongestionControl["DEFAULT_PUSH"] = 0] = "DEFAULT_PUSH";
    CongestionControl[CongestionControl["DEFAULT_REQUEST"] = 1] = "DEFAULT_REQUEST";
    CongestionControl[CongestionControl["DEFAULT_RESPONSE"] = 1] = "DEFAULT_RESPONSE";
})(CongestionControl || (CongestionControl = {}));
// The publisher reliability.
// Currently `reliability` does not trigger any data retransmission on the wire.
//  It is rather used as a marker on the wire and it may be used to select the best link available (e.g. TCP for reliable data and UDP for best effort data).
export var Reliability;
(function (Reliability) {
    Reliability[Reliability["BEST_EFFORT"] = 0] = "BEST_EFFORT";
    Reliability[Reliability["RELIABLE"] = 1] = "RELIABLE";
    Reliability[Reliability["DEFAULT"] = 1] = "DEFAULT";
})(Reliability || (Reliability = {}));
// The locality of samples to be received by subscribers or targeted by publishers.
export var Locality;
(function (Locality) {
    Locality[Locality["SESSION_LOCAL"] = 0] = "SESSION_LOCAL";
    Locality[Locality["REMOTE"] = 1] = "REMOTE";
    Locality[Locality["ANY"] = 2] = "ANY";
    Locality[Locality["DEFAULT"] = 2] = "DEFAULT";
})(Locality || (Locality = {}));
export var SampleKind;
(function (SampleKind) {
    SampleKind[SampleKind["PUT"] = 0] = "PUT";
    SampleKind[SampleKind["DELETE"] = 1] = "DELETE";
})(SampleKind || (SampleKind = {}));
// The `zenoh.queryable.Queryables that should be target of a `zenoh.Session.get()`.
export var QueryTarget;
(function (QueryTarget) {
    // Let Zenoh find the BestMatching queryable capabale of serving the query.
    QueryTarget[QueryTarget["BEST_MATCHING"] = 0] = "BEST_MATCHING";
    // Deliver the query to all queryables matching the query's key expression.
    QueryTarget[QueryTarget["ALL"] = 1] = "ALL";
    // Deliver the query to all queryables matching the query's key expression that are declared as complete.
    QueryTarget[QueryTarget["ALL_COMPLETE"] = 2] = "ALL_COMPLETE";
    QueryTarget[QueryTarget["DEFAULT"] = 0] = "DEFAULT";
})(QueryTarget || (QueryTarget = {}));
// The kind of consolidation to apply to a query.
export var ConsolidationMode;
(function (ConsolidationMode) {
    // Apply automatic consolidation based on queryable's preferences
    ConsolidationMode[ConsolidationMode["AUTO"] = 0] = "AUTO";
    // No consolidation applied: multiple samples may be received for the same key-timestamp.
    ConsolidationMode[ConsolidationMode["NONE"] = 1] = "NONE";
    // Monotonic consolidation immediately forwards samples, except if one with an equal or more recent timestamp
    // has already been sent with the same key.
    //
    // This optimizes latency while potentially reducing bandwidth.
    //
    // Note that this doesn't cause re-ordering, but drops the samples for which a more recent timestamp has already
    // been observed with the same key.
    ConsolidationMode[ConsolidationMode["MONOTONIC"] = 2] = "MONOTONIC";
    // Holds back samples to only send the set of samples that had the highest timestamp for their key.  
    ConsolidationMode[ConsolidationMode["LATEST"] = 3] = "LATEST";
    ConsolidationMode[ConsolidationMode["DEFAULT"] = 0] = "DEFAULT";
})(ConsolidationMode || (ConsolidationMode = {}));
// The kind of accepted query replies.
export var ReplyKeyExpr;
(function (ReplyKeyExpr) {
    // Accept replies whose key expressions may not match the query key expression.
    ReplyKeyExpr[ReplyKeyExpr["ANY"] = 0] = "ANY";
    // // Accept replies whose key expressions match the query key expression.
    ReplyKeyExpr[ReplyKeyExpr["MATCHING_QUERY"] = 1] = "MATCHING_QUERY";
    ReplyKeyExpr[ReplyKeyExpr["DEFAULT"] = 1] = "DEFAULT";
})(ReplyKeyExpr || (ReplyKeyExpr = {}));
//# sourceMappingURL=enums.js.map