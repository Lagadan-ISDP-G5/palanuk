import { IntoKeyExpr, KeyExpr } from "./key_expr.js";
import { IntoZBytes, ZBytes } from "./z_bytes.js";
import { Sample } from "./sample.js";
import { Encoding, IntoEncoding } from "./encoding.js";
import { Timestamp } from "./timestamp.js";
import { ChannelReceiver } from "./channels.js";
import { CongestionControl, Priority, ReplyKeyExpr } from "./enums.js";
import { SessionInner, QueryableId, GetId } from "./session_inner.js";
/**
 * Queryable class used to receive Query's from the network and handle Reply's
 * created by Session.declare_queryable
 */
export declare class Queryable {
    private session;
    private id;
    private keyExpr_;
    private receiver_?;
    /**
     * @ignore
     */
    [Symbol.asyncDispose](): Promise<void>;
    /**
     * @ignore
     * Returns a Queryable
     * Note! : user must use declare_queryable on a session
     */
    constructor(session: SessionInner, id: QueryableId, keyExpr_: KeyExpr, receiver_?: ChannelReceiver<Query> | undefined);
    /**
     * returns the key expression of an object
     * @returns KeyExpr
     */
    keyExpr(): KeyExpr;
    /**
     * returns a sample receiver for non-callback subscriber, undefined otherwise.
     *
     * @returns ChannelReceiver<Sample> | undefined
     */
    receiver(): ChannelReceiver<Query> | undefined;
    /**
     * Undeclares Queryable
     * @returns void
     */
    undeclare(): Promise<void>;
}
/**
 * Options for a Query.Reply operation
 * @prop {IntoEncoding=} encoding - Encoding type of reply payload
 * @prop {CongestionControl=} congestionControl - congestionControl applied when routing the reply
 * @prop {Priority=} priority - priority of the reply
 * @prop {boolean=} express  - Express: if set to `true`, this reply will not be batched. This usually has a positive impact on latency but negative impact on throughput.
 * @prop {Timestamp=} timestamp - Timestamp of the reply
 * @prop {IntoZBytes=} attachment - Additional Data sent with the reply
*/
export interface ReplyOptions {
    encoding?: IntoEncoding;
    congestionControl?: CongestionControl;
    priority?: Priority;
    express?: boolean;
    timestamp?: Timestamp;
    attachment?: IntoZBytes;
}
/**
 * Options for a Query.replyErr operation
 * @prop {IntoEncoding=} encoding - Encoding type of reply payload
 */
export interface ReplyErrOptions {
    encoding?: Encoding;
}
/**
 * Options for a Query.ReplyDel operation
 * @prop {CongestionControl=} congestionControl - congestion control applied when routing the reply
 * @prop {Priority=} priority - priority of the reply
 * @prop {boolean=} express  - Express:  if set to `true`, this reply will not be batched. This usually has a positive impact on latency but negative impact on throughput.
 * @prop {Timestamp=} timestamp - Timestamp of the reply
 * @prop {IntoZBytes=} attachment - Additional Data sent with the reply
 */
export interface ReplyDelOptions {
    priority?: Priority;
    congestionControl?: CongestionControl;
    express?: boolean;
    timestamp?: Timestamp;
    attachment?: IntoZBytes;
}
export declare class QueryInner {
    readonly queryId: GetId;
    readonly keyexpr_: KeyExpr;
    readonly parameters_: Parameters;
    readonly payload_: ZBytes | undefined;
    readonly encoding_: Encoding | undefined;
    readonly attachment_: ZBytes | undefined;
    readonly replyKeyExpr_: ReplyKeyExpr;
    constructor(queryId: GetId, keyexpr_: KeyExpr, parameters_: Parameters, payload_: ZBytes | undefined, encoding_: Encoding | undefined, attachment_: ZBytes | undefined, replyKeyExpr_: ReplyKeyExpr);
}
/**
 * A Zenoh Query
 * @remarks Once all replies have been sent, it is necessary to call Query.finalize
 * to signal, that no more replies will be provided by the given queryable, otherwise this
 * will result in query timeout error on the querier side.
 */
export declare class Query {
    private session;
    private inner;
    /**
      * @ignore
      *
      */
    constructor(session: SessionInner, inner: QueryInner);
    /**
     * gets an selector of Query
     * @returns Selector
     */
    selector(): Selector;
    /**
     * gets the KeyExpr of Query
     * @returns KeyExpr
     */
    keyExpr(): KeyExpr;
    /**
     * gets the Parameters of Query
     * @returns Parameters
     */
    parameters(): Parameters;
    /**
      * gets the Optioanl payload of Query
      * @returns ZBytes | undefined
      */
    payload(): ZBytes | undefined;
    /**
      * gets the Optional Encoding of a Query
      * @returns Encoding | undefined
      */
    encoding(): Encoding | undefined;
    /**
      * gets the Optional Attachment of a Query
      * @returns ZBytes | undefined
      */
    attachment(): ZBytes | undefined;
    /**
      * Sends a Reply to for Query
      * @param {IntoKeyExpr} intoKeyExpr
      * @param {IntoZBytes} payload
      * @param {ReplyOptions=} replyOpts
      * @returns void
      */
    reply(intoKeyExpr: IntoKeyExpr, payload: IntoZBytes, replyOpts?: ReplyOptions): Promise<void>;
    /**
    * Sends an Error Reply for a query
    * @param {IntoZBytes} payload
    * @param {ReplyErrOptions=} replyErrOpts
    * @returns void
    */
    replyErr(payload: IntoZBytes, replyErrOpts?: ReplyErrOptions): Promise<void>;
    /**
      * Sends an Error Reply for a query
      * @param intoKeyExpr IntoKeyExpr
      * @param {ReplyDelOptions=} replyDelOpts
      * @returns void
      */
    replyDel(intoKeyExpr: IntoKeyExpr, replyDelOpts?: ReplyDelOptions): Promise<void>;
    /**
      * Finalizes query, signaling that all replies have been sent.
      * @returns void
      */
    finalize(): Promise<void>;
    toString(): string;
    [Symbol.asyncDispose](): Promise<void>;
}
export type IntoParameters = Parameters | string | String | Map<string, string>;
/**
 * Parameters of a Query
 * Can be parsed from a String, using `;` or `<newline>` as separator between each parameters
 * and `=` as separator between a key and its value. Keys and values are trimmed.
 *
 * Example:
 * `let a = "a=1;b=2;c=3|4|5;d=6"`
 * `let p = Parameters.new(a)`
 */
export declare class Parameters {
    private source;
    constructor(intoParameters: IntoParameters);
    private iterByKeyValuePos;
    /**
     * Creates empty Parameters Structs
     * @returns Parameters
     */
    static empty(): Parameters;
    /**
     * removes a key from the parameters
     * @returns boolean
     */
    remove(key: string): boolean;
    /**
     * gets an generator over the pairs (key,value) of the Parameters
     * @returns Generator<string>
     */
    iter(): Generator<[string, string]>;
    /**
     * gets an generator over the values separated by `|`  in multivalue parameters
     * @returns Generator<string>
     */
    values(key: string): Generator<string>;
    /**
     * Returns true if properties does not contain anything.
     * @returns boolean
     */
    isEmpty(): boolean;
    /**
     * checks if parameters contains key
     * @returns boolean
     */
    containsKey(key: string): boolean;
    /**
     * gets first found value with associated key, returning undefined if key does not exist
     * @returns string | undefined
     */
    get(key: string): string | undefined;
    /**
     * Inserts new key,value pair into parameter
     * @returns void
     */
    insert(key: string, value: string): void;
    /**
     * extends this Parameters with the value of other parameters, overwriting `this` if keys match.
     * @returns void
     */
    extend(other: IntoParameters): void;
    /**
     * returns the string representation of the parameters
     * @returns string
     */
    toString(): string;
}
/**
 * ReplyError returned from a `get` on a session
 *
 */
export declare class ReplyError {
    private payload_;
    private encoding_;
    /**
     * Payload of Error Reply
     * @returns ZBytes
     */
    payload(): ZBytes;
    /**
     * Encoding of Error Reply
     * @returns Encoding
     */
    encoding(): Encoding;
    /**
      * @internal
      */
    constructor(payload_: ZBytes, encoding_: Encoding);
}
/**
 * Reply object from a zenoh `get`
 */
export declare class Reply {
    private result_;
    /**
     * Payload of Error Reply
     * @returns Sample or ReplyError
     */
    result(): Sample | ReplyError;
    /**
     * @internal
     */
    constructor(result_: Sample | ReplyError);
}
export type IntoSelector = Selector | KeyExpr | [KeyExpr, Parameters] | String | string;
/**
 * Selector class, holding a key expression and optional Parameters
 * in the following format `<KeyExpr>?<Params>`
 * example: `demo/key/expr?arg1=lol;arg2=hi`
 */
export declare class Selector {
    private keyExpr_;
    private parameters_;
    /**
     * gets Key Expression part of Selector
     * @returns KeyExpr
     */
    keyExpr(): KeyExpr;
    /**
     * gets Parameters part of Selector
     * @returns Parameters
     */
    parameters(): Parameters;
    toString(): string;
    /**
     * New Function to create a selector from Selector / KeyExpr and Parameters
     * @returns Selector
     */
    static from(selector: IntoSelector): Selector;
    /**
     * New Function to create a selector from Selector / KeyExpr and Parameters
     * @returns Selector
     */
    constructor(keyexpr: IntoKeyExpr, parameters?: IntoParameters);
}
