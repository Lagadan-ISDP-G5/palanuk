import { SimpleChannel, TryReceived, TryReceivedKind, ChannelState } from "channel-ts";
import { Callback, Drop } from "./closure";
/**
 * A receiver interface for channel.
 */
export interface ChannelReceiver<T> {
    state: () => ChannelState;
    receive: () => Promise<T>;
    tryReceive(): TryReceived<T>;
    [Symbol.asyncIterator]: () => AsyncIterableIterator<T>;
}
/**
 * A sender interface for channel.
 */
export interface ChannelSender<T> {
    send: (data: T) => void;
    close: () => void;
}
export interface IntoSenderReceiverPair<T> {
    intoSenderReceiverPair: () => [ChannelSender<T>, ChannelReceiver<T>];
}
export declare function isIntoSenderReceiverPair<T>(object: any): object is IntoSenderReceiverPair<T>;
export type Handler<T> = Callback<T> | [Callback<T>, Drop] | IntoSenderReceiverPair<T>;
export declare function intoCbDropReceiver<T>(handler: Handler<T>): [Callback<T>, Drop, ChannelReceiver<T>?];
/**
 * A FIFO channel. When maximum capacity is reached all new values will be ignored.
 */
export declare class FifoChannel<T> {
    protected chan: SimpleChannel<T>;
    protected capacity: number;
    protected size: number;
    constructor(capacity: number);
    /**
     * Send new data onto channel. When maximum capacity is reached all new values will be ignored.
     */
    send(data: T): void;
    /**
     * Get state of the channel.
     */
    state(): ChannelState;
    /**
     * Attempt to receive the data in a non-blocking way.
     */
    tryReceive(): TryReceived<T>;
    /**
     * Receive data in a blocking way. If channel is empty, this call will block until new data arrives or the channel is closed.
     */
    receive(): Promise<T>;
    /**
     * Close the channel. This`will unblock all currently pending @see receive calls.
     */
    close(): void;
    [Symbol.asyncIterator](): AsyncIterableIterator<T>;
    /**
     * Split Channel into @interface ChannelSender and @interface ChannelReceiver pair.
     */
    intoSenderReceiverPair(): [ChannelSender<T>, ChannelReceiver<T>];
}
/**
 * A circular buffer channel. When maximum capacity is reached the older values will be removed to provide space for new ones.
 */
export declare class RingChannel<T> extends FifoChannel<T> {
    constructor(capacity: number);
    /**
     * Send new data onto channel. When maximum capacity is reached the older values will be removed to provide space for new ones.
     */
    send(data: T): void;
}
export { TryReceivedKind, ChannelState, TryReceived };
