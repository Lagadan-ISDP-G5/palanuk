import { ZBytes } from "./z_bytes.js";
import { Encoding } from "./encoding.js";
import { FifoChannel, intoCbDropReceiver } from "./channels.js";
import { SubscriberKind } from "./session_inner.js";
import { PublisherDelete, PublisherPut } from "./message.js";
import { MatchingListener } from "./matching.js";
// ███████ ██    ██ ██████  ███████  ██████ ██████  ██ ██████  ███████ ██████
// ██      ██    ██ ██   ██ ██      ██      ██   ██ ██ ██   ██ ██      ██   ██
// ███████ ██    ██ ██████  ███████ ██      ██████  ██ ██████  █████   ██████
//      ██ ██    ██ ██   ██      ██ ██      ██   ██ ██ ██   ██ ██      ██   ██
// ███████  ██████  ██████  ███████  ██████ ██   ██ ██ ██████  ███████ ██   ██
/**
 * Class to represent a Subscriber on Zenoh,
 * created via calling `declare_subscriber()` on a `session`
 */
export class Subscriber {
    session;
    kind;
    id;
    keyExpr_;
    receiver_;
    /**
     * @ignore
     */
    async [Symbol.asyncDispose]() {
        await this.undeclare();
    }
    /**
     * @ignore
     */
    constructor(session, kind, id, keyExpr_, receiver_) {
        this.session = session;
        this.kind = kind;
        this.id = id;
        this.keyExpr_ = keyExpr_;
        this.receiver_ = receiver_;
    }
    /**
     * returns the key expression of an object
     * @returns KeyExpr
     */
    keyExpr() {
        return this.keyExpr_;
    }
    /**
     * returns a sample receiver for non-callback subscriber, undefined otherwise.
     *
     * @returns ChannelReceiver<Sample> | undefined
     */
    receiver() {
        return this.receiver_;
    }
    /**
     * Undeclares a subscriber on the session
     *
     */
    async undeclare() {
        if (this.kind === SubscriberKind.Subscriber) {
            await this.session.undeclareSubscriber(this.id);
        }
        else {
            await this.session.undeclareLivelinessSubscriber(this.id);
        }
    }
}
/**
 * Class that represents a Zenoh Publisher,
 * created by calling `Session.declarePublisher()`
 */
export class Publisher {
    session;
    publisherId;
    properties;
    /**
     * @ignore
     */
    async [Symbol.asyncDispose]() {
        await this.undeclare();
    }
    /**
     * @ignore
     */
    constructor(session, publisherId, properties) {
        this.session = session;
        this.publisherId = publisherId;
        this.properties = properties;
    }
    /**
     * gets the Key Expression from Publisher
     *
     * @returns {KeyExpr} instance
     */
    keyExpr() {
        return this.properties.keyexpr;
    }
    /**
     * Puts a payload on the publisher associated with this class instance
     *
     * @param {IntoZBytes} payload
     * @param {PublisherPutOptions} putOptions
     *
     * @returns void
     */
    async put(payload, putOptions) {
        await this.session.publisherPut(new PublisherPut(this.publisherId, new ZBytes(payload), putOptions?.encoding ? Encoding.from(putOptions.encoding) : undefined, putOptions?.attachment ? new ZBytes(putOptions.attachment) : undefined, putOptions?.timestamp));
    }
    /**
    * get Encoding declared for Publisher
    *
    * @returns {Encoding}
    */
    encoding() {
        return this.properties.encoding;
    }
    /**
    * get Priority declared for Publisher
    *
    * @returns {Priority}
    */
    priority() {
        return this.properties.qos.priority;
    }
    /**
    * get Reliability declared for Publisher
    *
    * @returns {Reliability}
    */
    reliability() {
        return this.properties.qos.reliability;
    }
    /**
     * get Congestion Control declared for a Publisher
     *
     * @returns {CongestionControl}
     */
    congestionControl() {
        return this.properties.qos.congestionControl;
    }
    /**
     *
     * executes delete on publisher
     * @param {PublisherDeleteOptions=} deleteOptions:  Options associated with a publishers delete
     * @returns void
     */
    async delete(deleteOptions) {
        await this.session.publisherDelete(new PublisherDelete(this.publisherId, deleteOptions?.attachment ? new ZBytes(deleteOptions.attachment) : undefined, deleteOptions?.timestamp));
    }
    /**
     * Declares a new matching listener, notifying when publisher's `Matching Status` changes.
     *
     * @remarks
     *  If a Matching listener is created with a callback, it cannot be simultaneously polled for new values.
     *
     * @param {MatchingListenerOptions} matchingListenerOptions - optional additional parameters for matching listener.
     *
     * @returns Matching listener
     */
    async matchingListener(matchingListenerOptions) {
        const handler = matchingListenerOptions?.handler ?? new FifoChannel(256);
        let [callback, drop, receiver] = intoCbDropReceiver(handler);
        const listenerId = await this.session.publisherDeclareMatchingListener(this.publisherId, { callback, drop });
        return new MatchingListener(this.session, listenerId, receiver);
    }
    /**
     * Gets publisher matching status - i.e. if there are any subscribers matching its key expression.
     *
     * @returns Publisher matching status
     */
    async matchingStatus() {
        return await this.session.publisherGetMatchingStatus(this.publisherId);
    }
    /**
     * undeclares publisher
     *
     * @returns void
     */
    async undeclare() {
        await this.session.undeclarePublisher(this.publisherId);
    }
}
//# sourceMappingURL=pubsub.js.map