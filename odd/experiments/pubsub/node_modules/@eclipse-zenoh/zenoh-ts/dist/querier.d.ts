import { IntoZBytes } from "./z_bytes.js";
import { KeyExpr } from "./key_expr.js";
import { IntoParameters, Reply } from "./query.js";
import { ChannelReceiver, Handler } from "./channels.js";
import { IntoEncoding } from "./encoding.js";
import { SessionInner, QuerierId } from "./session_inner.js";
import { CongestionControl, Priority, ReplyKeyExpr } from "./enums.js";
import { MatchingListener, MatchingListenerOptions, MatchingStatus } from "./matching.js";
import { CancellationToken } from "./cancellation_token.js";
/**
 * Options for a Querier Get operation
 * @prop {IntoParameters=} parameters - Optional query parameters
 * @prop {IntoEncoding=} encoding - Encoding type of payload
 * @prop {IntoZBytes=} payload - Payload associated with the query
 * @prop {IntoZBytes=} attachment - Additional Data sent with the query
 * @prop {Handler<Reply>=} handler - A reply handler
 * @prop {CancellationToken=} cancellationToken - Token to interrupt the query. Warning: This API has been marked as unstable: it works as advertised, but it may be changed in a future release.
*/
export interface QuerierGetOptions {
    parameters?: IntoParameters;
    encoding?: IntoEncoding;
    payload?: IntoZBytes;
    attachment?: IntoZBytes;
    handler?: Handler<Reply>;
    cancellationToken?: CancellationToken;
}
/**
 * Queryable class used to receive Query's from the network and handle Reply's
 * created by Session.declare_queryable
 */
export declare class Querier {
    private session;
    private querierId;
    private keyExpr_;
    private congestionControl_;
    private priority_;
    private acceptReplies_;
    /**
     * @ignore
     */
    [Symbol.asyncDispose](): Promise<void>;
    /**
     * @ignore
     */
    constructor(session: SessionInner, querierId: QuerierId, keyExpr_: KeyExpr, congestionControl_: CongestionControl, priority_: Priority, acceptReplies_: ReplyKeyExpr);
    /**
     * Undeclares Queryable
     * @returns void
     */
    undeclare(): Promise<void>;
    /**
     * returns key expression for this Querier
     * @returns KeyExpr
     */
    keyExpr(): KeyExpr;
    /**
     * returns Congestion Control for this Querier
     * @returns CongestionControl
     */
    congestionControl(): CongestionControl;
    /**
     * returns Priority for this Querier
     * @returns Priority
     */
    priority(): Priority;
    /**
     * returns ReplyKeyExpr for this Querier
     * @returns ReplyKeyExpr
     */
    acceptReplies(): ReplyKeyExpr;
    /**
     * Issue a Get request on this querier
     * @returns Promise <Receiever | void>
     */
    get(getOpts?: QuerierGetOptions): Promise<ChannelReceiver<Reply> | undefined>;
    /**
     * Declares a new matching listener, notifying when querier's `Matching Status` changes.
     *
     * @remarks
     *  If a Matching listener is created with a callback, it cannot be simultaneously polled for new values.
     *
     * @param {MatchingListenerOptions} matchingListenerOptions - optional additional parameters for matching listener.
     *
     * @returns Matching listener
     */
    matchingListener(matchingListenerOptions?: MatchingListenerOptions): Promise<MatchingListener>;
    /**
     * Gets querier matching status - i.e. if there are any queryables matching its key expression and target.
     *
     * @returns Querier matching status
     */
    matchingStatus(): Promise<MatchingStatus>;
}
