import { KeyExpr } from "./key_expr.js";
import { Delete, GetProperties, LivelinessGetProperties, LivelinessSubscriberProperties, PublisherDelete, PublisherProperties, PublisherPut, Put, QuerierGetProperties, QuerierProperties, QueryableProperties, ReplyDel, ReplyErr, ReplyOk, ResponsePing, SubscriberProperties } from "./message.js";
import { Query, Reply } from "./query.js";
import { Closure } from "./closure.js";
import { Sample } from "./sample.js";
import { SessionInfo } from "./session.js";
import { Timestamp } from "./timestamp.js";
import { MatchingStatus } from "./matching.js";
declare const publisherIdBrand: unique symbol;
declare const subscriberIdBrand: unique symbol;
declare const queryableIdBrand: unique symbol;
declare const querierIdBrand: unique symbol;
declare const livelinessTokenIdBrand: unique symbol;
declare const getIdBrand: unique symbol;
declare const matchingListenerIdBrand: unique symbol;
export type PublisherId = number & {
    readonly [publisherIdBrand]: typeof publisherIdBrand;
};
export type SubscriberId = number & {
    readonly [subscriberIdBrand]: typeof subscriberIdBrand;
};
export type QueryableId = number & {
    readonly [queryableIdBrand]: typeof queryableIdBrand;
};
export type QuerierId = number & {
    readonly [querierIdBrand]: typeof querierIdBrand;
};
export type LivelinessTokenId = number & {
    readonly [livelinessTokenIdBrand]: typeof livelinessTokenIdBrand;
};
export type GetId = number & {
    readonly [getIdBrand]: typeof getIdBrand;
};
export type MatchingListenerId = number & {
    readonly [matchingListenerIdBrand]: typeof matchingListenerIdBrand;
};
export declare enum SubscriberKind {
    Subscriber = 0,
    LivelinessSubscriber = 1
}
export declare class SessionInner {
    private isClosed_;
    private link;
    private id;
    private subscribers;
    private queryables;
    private gets;
    private matchingListeners;
    private pendingMessageResponses;
    private nextMessageId;
    private readonly messageResponseTimeoutMs;
    private constructor();
    private onMessageReceived;
    private sendMessage;
    private sendRequest;
    ping(): Promise<ResponsePing>;
    static open(locator: string, messageResponseTimeoutMs: number): Promise<SessionInner>;
    declarePublisher(info: PublisherProperties): Promise<PublisherId>;
    undeclarePublisher(publisherId: PublisherId): Promise<void>;
    declareSubscriber(info: SubscriberProperties, closure: Closure<Sample>): Promise<SubscriberId>;
    undeclareSubscriber(subscriberId: SubscriberId): Promise<void>;
    declareQueryable(info: QueryableProperties, closure: Closure<Query>): Promise<QueryableId>;
    undeclareQueryable(queryableId: QueryableId): Promise<void>;
    declareQuerier(info: QuerierProperties): Promise<QuerierId>;
    undeclareQuerier(querierId: QuerierId): Promise<void>;
    declareLivelinessToken(keyexpr: KeyExpr): Promise<LivelinessTokenId>;
    undeclareLivelinessToken(tokenId: LivelinessTokenId): Promise<void>;
    declareLivelinessSubscriber(info: LivelinessSubscriberProperties, closure: Closure<Sample>): Promise<SubscriberId>;
    undeclareLivelinessSubscriber(livelinessSubscriberId: SubscriberId): Promise<void>;
    getSessionInfo(): Promise<SessionInfo>;
    getTimestamp(): Promise<Timestamp>;
    put(data: Put): Promise<void>;
    delete(data: Delete): Promise<void>;
    publisherPut(data: PublisherPut): Promise<void>;
    publisherDelete(data: PublisherDelete): Promise<void>;
    get(data: GetProperties, closure: Closure<Reply>): Promise<GetId>;
    querierGet(data: QuerierGetProperties, closure: Closure<Reply>): Promise<GetId>;
    livelinessGet(data: LivelinessGetProperties, closure: Closure<Reply>): Promise<GetId>;
    replyOk(data: ReplyOk): Promise<void>;
    replyDel(data: ReplyDel): Promise<void>;
    replyErr(data: ReplyErr): Promise<void>;
    sendResponseFinal(queryId: GetId): Promise<void>;
    publisherDeclareMatchingListener(publisherId: PublisherId, closure: Closure<MatchingStatus>): Promise<MatchingListenerId>;
    undeclareMatchingListener(listenerId: MatchingListenerId): Promise<void>;
    publisherGetMatchingStatus(publisherId: PublisherId): Promise<MatchingStatus>;
    querierDeclareMatchingListener(querierId: QuerierId, closure: Closure<MatchingStatus>): Promise<MatchingListenerId>;
    querierGetMatchingStatus(querierId: QuerierId): Promise<MatchingStatus>;
    close(): Promise<void>;
    isClosed(): boolean;
    cancelQuery(queryId: GetId): void;
}
export {};
