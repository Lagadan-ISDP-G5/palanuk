import { KeyExpr } from "./key_expr.js";
import { IntoZBytes } from "./z_bytes.js";
import { Sample } from "./sample.js";
import { Encoding, IntoEncoding } from "./encoding.js";
import { Timestamp } from "./timestamp.js";
import { ChannelReceiver } from "./channels.js";
import { SessionInner, PublisherId, SubscriberId, SubscriberKind } from "./session_inner.js";
import { PublisherProperties } from "./message.js";
import { CongestionControl, Priority, Reliability } from "./enums.js";
import { MatchingListener, MatchingListenerOptions, MatchingStatus } from "./matching.js";
/**
 * Class to represent a Subscriber on Zenoh,
 * created via calling `declare_subscriber()` on a `session`
 */
export declare class Subscriber {
    private session;
    private kind;
    private id;
    private keyExpr_;
    private receiver_?;
    /**
     * @ignore
     */
    [Symbol.asyncDispose](): Promise<void>;
    /**
     * @ignore
     */
    constructor(session: SessionInner, kind: SubscriberKind, id: SubscriberId, keyExpr_: KeyExpr, receiver_?: ChannelReceiver<Sample> | undefined);
    /**
     * returns the key expression of an object
     * @returns KeyExpr
     */
    keyExpr(): KeyExpr;
    /**
     * returns a sample receiver for non-callback subscriber, undefined otherwise.
     *
     * @returns ChannelReceiver<Sample> | undefined
     */
    receiver(): ChannelReceiver<Sample> | undefined;
    /**
     * Undeclares a subscriber on the session
     *
     */
    undeclare(): Promise<void>;
}
/**
 * @param {IntoEncoding=} encoding  - Encoding parameter for Zenoh data
 * @param {IntoZBytes=} attachment - optional extra data to send with Payload
 */
export interface PublisherPutOptions {
    encoding?: IntoEncoding;
    attachment?: IntoZBytes;
    timestamp?: Timestamp;
}
/**
 * @param {IntoZBytes=} attachment - optional extra data to send with Payload
 */
export interface PublisherDeleteOptions {
    attachment?: IntoZBytes;
    timestamp?: Timestamp;
}
/**
 * Class that represents a Zenoh Publisher,
 * created by calling `Session.declarePublisher()`
 */
export declare class Publisher {
    private session;
    private publisherId;
    private properties;
    /**
     * @ignore
     */
    [Symbol.asyncDispose](): Promise<void>;
    /**
     * @ignore
     */
    constructor(session: SessionInner, publisherId: PublisherId, properties: PublisherProperties);
    /**
     * gets the Key Expression from Publisher
     *
     * @returns {KeyExpr} instance
     */
    keyExpr(): KeyExpr;
    /**
     * Puts a payload on the publisher associated with this class instance
     *
     * @param {IntoZBytes} payload
     * @param {PublisherPutOptions} putOptions
     *
     * @returns void
     */
    put(payload: IntoZBytes, putOptions?: PublisherPutOptions): Promise<void>;
    /**
    * get Encoding declared for Publisher
    *
    * @returns {Encoding}
    */
    encoding(): Encoding;
    /**
    * get Priority declared for Publisher
    *
    * @returns {Priority}
    */
    priority(): Priority;
    /**
    * get Reliability declared for Publisher
    *
    * @returns {Reliability}
    */
    reliability(): Reliability;
    /**
     * get Congestion Control declared for a Publisher
     *
     * @returns {CongestionControl}
     */
    congestionControl(): CongestionControl;
    /**
     *
     * executes delete on publisher
     * @param {PublisherDeleteOptions=} deleteOptions:  Options associated with a publishers delete
     * @returns void
     */
    delete(deleteOptions?: PublisherDeleteOptions): Promise<void>;
    /**
     * Declares a new matching listener, notifying when publisher's `Matching Status` changes.
     *
     * @remarks
     *  If a Matching listener is created with a callback, it cannot be simultaneously polled for new values.
     *
     * @param {MatchingListenerOptions} matchingListenerOptions - optional additional parameters for matching listener.
     *
     * @returns Matching listener
     */
    matchingListener(matchingListenerOptions?: MatchingListenerOptions): Promise<MatchingListener>;
    /**
     * Gets publisher matching status - i.e. if there are any subscribers matching its key expression.
     *
     * @returns Publisher matching status
     */
    matchingStatus(): Promise<MatchingStatus>;
    /**
     * undeclares publisher
     *
     * @returns void
     */
    undeclare(): Promise<void>;
}
