//
// Copyright (c) 2024 ZettaScale Technology
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0
// which is available at https://www.apache.org/licenses/LICENSE-2.0.
//
// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
//
// Contributors:
//   ZettaScale Zenoh Team, <zenoh@zettascale.tech>
//
import { ZBytes } from "./z_bytes.js";
import { Parameters } from "./query.js";
import { FifoChannel, intoCbDropReceiver } from "./channels.js";
import { Encoding } from "./encoding.js";
import { MatchingListener } from "./matching.js";
/**
 * Queryable class used to receive Query's from the network and handle Reply's
 * created by Session.declare_queryable
 */
export class Querier {
    session;
    querierId;
    keyExpr_;
    congestionControl_;
    priority_;
    acceptReplies_;
    /**
     * @ignore
     */
    async [Symbol.asyncDispose]() {
        await this.undeclare();
    }
    /**
     * @ignore
     */
    constructor(session, querierId, keyExpr_, congestionControl_, priority_, acceptReplies_) {
        this.session = session;
        this.querierId = querierId;
        this.keyExpr_ = keyExpr_;
        this.congestionControl_ = congestionControl_;
        this.priority_ = priority_;
        this.acceptReplies_ = acceptReplies_;
    }
    /**
     * Undeclares Queryable
     * @returns void
     */
    async undeclare() {
        await this.session.undeclareQuerier(this.querierId);
    }
    /**
     * returns key expression for this Querier
     * @returns KeyExpr
     */
    keyExpr() {
        return this.keyExpr_;
    }
    /**
     * returns Congestion Control for this Querier
     * @returns CongestionControl
     */
    congestionControl() {
        return this.congestionControl_;
    }
    /**
     * returns Priority for this Querier
     * @returns Priority
     */
    priority() {
        return this.priority_;
    }
    /**
     * returns ReplyKeyExpr for this Querier
     * @returns ReplyKeyExpr
     */
    acceptReplies() {
        return this.acceptReplies_;
    }
    /**
     * Issue a Get request on this querier
     * @returns Promise <Receiever | void>
     */
    async get(getOpts) {
        let handler = getOpts?.handler ?? new FifoChannel(256);
        let [callback, drop, receiver] = intoCbDropReceiver(handler);
        let cancellationToken = getOpts?.cancellationToken;
        if (cancellationToken?.isCancelled() ?? false) {
            drop();
            return receiver;
        }
        let getId = await this.session.querierGet({
            querierId: this.querierId,
            parameters: getOpts?.parameters ? new Parameters(getOpts.parameters).toString() : "",
            payload: getOpts?.payload ? new ZBytes(getOpts.payload) : undefined,
            encoding: getOpts?.encoding ? Encoding.from(getOpts.encoding) : undefined,
            attachment: getOpts?.attachment ? new ZBytes(getOpts.attachment) : undefined,
        }, { callback, drop });
        cancellationToken?.addCancelAction(() => this.session.cancelQuery(getId));
        return receiver;
    }
    /**
     * Declares a new matching listener, notifying when querier's `Matching Status` changes.
     *
     * @remarks
     *  If a Matching listener is created with a callback, it cannot be simultaneously polled for new values.
     *
     * @param {MatchingListenerOptions} matchingListenerOptions - optional additional parameters for matching listener.
     *
     * @returns Matching listener
     */
    async matchingListener(matchingListenerOptions) {
        const handler = matchingListenerOptions?.handler ?? new FifoChannel(256);
        let [callback, drop, receiver] = intoCbDropReceiver(handler);
        const listenerId = await this.session.querierDeclareMatchingListener(this.querierId, { callback, drop });
        return new MatchingListener(this.session, listenerId, receiver);
    }
    /**
     * Gets querier matching status - i.e. if there are any queryables matching its key expression and target.
     *
     * @returns Querier matching status
     */
    async matchingStatus() {
        return await this.session.querierGetMatchingStatus(this.querierId);
    }
}
//# sourceMappingURL=querier.js.map