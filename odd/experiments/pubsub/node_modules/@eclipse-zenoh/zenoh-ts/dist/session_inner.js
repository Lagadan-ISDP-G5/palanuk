//
// Copyright (c) 2025 ZettaScale Technology
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0
// which is available at https://www.apache.org/licenses/LICENSE-2.0.
//
// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
//
// Contributors:
//   ZettaScale Zenoh Team, <zenoh@zettascale.tech>
//
// Remote API interface
import { ZBytesDeserializer, ZBytesSerializer } from "./ext/index.js";
import { DeclareLivelinessSubscriber, DeclareLivelinessToken, DeclarePublisher, DeclareQuerier, DeclareQueryable, DeclareSubscriber, deserializeHeader, Get, GetSessionInfo, GetTimestamp, InQuery, InRemoteMessageId, InReply, InSample, LivelinessGet, MatchingStatusUpdate, Ping, PublisherDeclareMatchingListener, PublisherGetMatchingStatus, QuerierDeclareMatchingListener, QuerierGet, QuerierGetMatchingStatus, QueryResponseFinal, ResponseError, ResponseMatchingStatus, ResponseOk, ResponsePing, ResponseSessionInfo, ResponseTimestamp, serializeHeader, UndeclareLivelinessSubscriber, UndeclareLivelinessToken, UndeclareMatchingListener, UndeclarePublisher, UndeclareQuerier, UndeclareQueryable, UndeclareSubscriber } from "./message.js";
import { Query } from "./query.js";
import { RemoteLink } from "./link.js";
import { MatchingStatus } from "./matching.js";
export var SubscriberKind;
(function (SubscriberKind) {
    SubscriberKind[SubscriberKind["Subscriber"] = 0] = "Subscriber";
    SubscriberKind[SubscriberKind["LivelinessSubscriber"] = 1] = "LivelinessSubscriber";
})(SubscriberKind || (SubscriberKind = {}));
class IdSource {
    static MAX = 1 << 31;
    static current = 0;
    static get() {
        const ret = IdSource.current;
        if (IdSource.current == IdSource.MAX) {
            IdSource.current = 0;
        }
        else {
            IdSource.current++;
        }
        return ret;
    }
}
export class SessionInner {
    isClosed_ = false;
    link;
    id = "";
    subscribers = new Map();
    queryables = new Map();
    gets = new Map();
    matchingListeners = new Map();
    pendingMessageResponses = new Map();
    nextMessageId = 0;
    messageResponseTimeoutMs;
    constructor(link, messageResponseTimeoutMs) {
        this.link = link;
        this.messageResponseTimeoutMs = messageResponseTimeoutMs;
        this.link.onmessage((msg) => {
            try {
                this.onMessageReceived(msg);
            }
            catch (e) {
                console.warn(e);
            }
        });
    }
    onMessageReceived(msg) {
        let deserializer = new ZBytesDeserializer(msg);
        let [messageId, sequenceId] = deserializeHeader(deserializer);
        if (sequenceId != undefined) { // received response to one of the messages
            let res = this.pendingMessageResponses.get(sequenceId);
            if (res == undefined) {
                console.warn(`Received unexpected response ${messageId}:${sequenceId}`);
            }
            else {
                res([messageId, deserializer]);
                this.pendingMessageResponses.delete(sequenceId);
            }
        }
        else {
            switch (messageId) {
                case InRemoteMessageId.InQuery: {
                    const q = InQuery.deserialize(deserializer);
                    let queryable = this.queryables.get(q.queryableId);
                    if (queryable == undefined) {
                        console.warn(`Received query for inexistant queryable ${q.queryableId}`);
                    }
                    else {
                        queryable.callback(new Query(this, q.query));
                    }
                    break;
                }
                case InRemoteMessageId.InReply: {
                    const r = InReply.deserialize(deserializer);
                    let get = this.gets.get(r.queryId);
                    if (get == undefined) {
                        console.warn(`Received reply for inexistant query ${r.queryId}`);
                    }
                    else {
                        get.callback(r.reply);
                    }
                    break;
                }
                case InRemoteMessageId.InSample: {
                    const s = InSample.deserialize(deserializer);
                    let subscriber = this.subscribers.get(s.subscriberId);
                    if (subscriber == undefined) {
                        console.warn(`Received sample for inexistant subscriber ${s.subscriberId}`);
                    }
                    else {
                        subscriber.callback(s.sample);
                    }
                    break;
                }
                case InRemoteMessageId.QueryResponseFinal: {
                    const q = QueryResponseFinal.deserialize(deserializer);
                    let get = this.gets.get(q.queryId);
                    if (get == undefined) {
                        console.warn(`Received responseFinal for inexistant get ${q.queryId}`);
                    }
                    else {
                        this.gets.delete(q.queryId);
                        get.drop();
                    }
                    break;
                }
                case InRemoteMessageId.MatchingStatusUpdate: {
                    const m = MatchingStatusUpdate.deserialize(deserializer);
                    let matchingListener = this.matchingListeners.get(m.matchingListenerId);
                    if (matchingListener == undefined) {
                        console.warn(`Received matching status update for inexistant matching listener ${m.matchingListenerId}`);
                    }
                    else {
                        matchingListener.callback(new MatchingStatus(m.matching));
                    }
                    break;
                }
                default: throw new Error(`Received unexpected message type ${messageId}`);
            }
        }
    }
    async sendMessage(msg) {
        let serializer = new ZBytesSerializer();
        serializer.serializeNumberUint8(msg.outMessageId);
        msg.serializeWithZSerializer(serializer);
        return await this.link.send(serializer.toBytes());
    }
    async sendRequest(msg, expectedResponseId, deserialize) {
        let serializer = new ZBytesSerializer();
        const msgId = this.nextMessageId;
        this.nextMessageId = (this.nextMessageId + 1) % (1 << 31);
        serializeHeader([msg.outMessageId, msgId], serializer);
        msg.serializeWithZSerializer(serializer);
        const p = new Promise((resolve, reject) => {
            let t = setTimeout(() => reject(), this.messageResponseTimeoutMs);
            this.pendingMessageResponses.set(msgId, (arg) => {
                clearTimeout(t);
                resolve(arg);
            });
        });
        await this.link.send(serializer.finish().toBytes());
        return await p.then((r) => {
            switch (r[0]) {
                case expectedResponseId: return deserialize(r[1]);
                case InRemoteMessageId.ResponseError: {
                    const e = ResponseError.deserialize(r[1]);
                    throw new Error(e.error);
                }
                default: throw new Error(`Unexpected InRemoteMessageId ${r[0]}`);
            }
            ;
        }, () => {
            this.pendingMessageResponses.delete(msgId);
            throw new Error("Remote api request timeout");
        });
    }
    async ping() {
        return await this.sendRequest(new Ping, InRemoteMessageId.ResponsePing, ResponsePing.deserialize);
    }
    static async open(locator, messageResponseTimeoutMs) {
        let link = await RemoteLink.new(locator);
        let session = new SessionInner(link, messageResponseTimeoutMs);
        session.id = (await session.ping()).uuid; // verify connection
        console.log(`Successfully opened session with id: ${session.id}`);
        return session;
    }
    async declarePublisher(info) {
        let publisherId = IdSource.get();
        await this.sendRequest(new DeclarePublisher(publisherId, info), InRemoteMessageId.ResponseOk, ResponseOk.deserialize);
        return publisherId;
    }
    async undeclarePublisher(publisherId) {
        await this.sendRequest(new UndeclarePublisher(publisherId), InRemoteMessageId.ResponseOk, ResponseOk.deserialize);
    }
    async declareSubscriber(info, closure) {
        let subscriberId = IdSource.get();
        this.subscribers.set(subscriberId, closure);
        try {
            await this.sendRequest(new DeclareSubscriber(subscriberId, info), InRemoteMessageId.ResponseOk, ResponseOk.deserialize);
        }
        catch (error) {
            this.subscribers.delete(subscriberId);
            throw error;
        }
        return subscriberId;
    }
    async undeclareSubscriber(subscriberId) {
        const subscriber = this.subscribers.get(subscriberId);
        if (subscriber == undefined) {
            new Error(`Unknown subscriber id: ${subscriberId}`);
        }
        else {
            this.subscribers.delete(subscriberId);
            subscriber.drop();
        }
        await this.sendRequest(new UndeclareSubscriber(subscriberId), InRemoteMessageId.ResponseOk, ResponseOk.deserialize);
    }
    async declareQueryable(info, closure) {
        let queryableId = IdSource.get();
        await this.sendRequest(new DeclareQueryable(queryableId, info), InRemoteMessageId.ResponseOk, ResponseOk.deserialize);
        this.queryables.set(queryableId, closure);
        return queryableId;
    }
    async undeclareQueryable(queryableId) {
        const queryable = this.queryables.get(queryableId);
        if (queryable == undefined) {
            new Error(`Unknown queryable id: ${queryableId}`);
        }
        else {
            this.queryables.delete(queryableId);
            queryable.drop();
        }
        await this.sendRequest(new UndeclareQueryable(queryableId), InRemoteMessageId.ResponseOk, ResponseOk.deserialize);
    }
    async declareQuerier(info) {
        let querierId = IdSource.get();
        await this.sendRequest(new DeclareQuerier(querierId, info), InRemoteMessageId.ResponseOk, ResponseOk.deserialize);
        return querierId;
    }
    async undeclareQuerier(querierId) {
        await this.sendRequest(new UndeclareQuerier(querierId), InRemoteMessageId.ResponseOk, ResponseOk.deserialize);
    }
    async declareLivelinessToken(keyexpr) {
        let tokenId = IdSource.get();
        await this.sendRequest(new DeclareLivelinessToken(tokenId, keyexpr), InRemoteMessageId.ResponseOk, ResponseOk.deserialize);
        return tokenId;
    }
    async undeclareLivelinessToken(tokenId) {
        await this.sendRequest(new UndeclareLivelinessToken(tokenId), InRemoteMessageId.ResponseOk, ResponseOk.deserialize);
    }
    async declareLivelinessSubscriber(info, closure) {
        let livelinessSubscriberId = IdSource.get();
        this.subscribers.set(livelinessSubscriberId, closure);
        try {
            await this.sendRequest(new DeclareLivelinessSubscriber(livelinessSubscriberId, info), InRemoteMessageId.ResponseOk, ResponseOk.deserialize);
        }
        catch (error) {
            this.subscribers.delete(livelinessSubscriberId);
            throw error;
        }
        return livelinessSubscriberId;
    }
    async undeclareLivelinessSubscriber(livelinessSubscriberId) {
        const livelinessSubscriber = this.subscribers.get(livelinessSubscriberId);
        if (livelinessSubscriber == undefined) {
            new Error(`Unknown liveliness subscriber id: ${livelinessSubscriberId}`);
        }
        else {
            this.subscribers.delete(livelinessSubscriberId);
            livelinessSubscriber.drop();
        }
        await this.sendRequest(new UndeclareLivelinessSubscriber(livelinessSubscriberId), InRemoteMessageId.ResponseOk, ResponseOk.deserialize);
    }
    async getSessionInfo() {
        return await this.sendRequest(new GetSessionInfo(), InRemoteMessageId.ResponseSessionInfo, ResponseSessionInfo.deserialize).then((value) => value.info);
    }
    async getTimestamp() {
        return await this.sendRequest(new GetTimestamp(), InRemoteMessageId.ResponseTimestamp, ResponseTimestamp.deserialize).then((value) => value.timestamp);
    }
    async put(data) {
        return await this.sendMessage(data);
    }
    async delete(data) {
        return await this.sendMessage(data);
    }
    async publisherPut(data) {
        return await this.sendMessage(data);
    }
    async publisherDelete(data) {
        return await this.sendMessage(data);
    }
    async get(data, closure) {
        let getId = IdSource.get();
        this.gets.set(getId, closure);
        try {
            await this.sendMessage(new Get(getId, data));
            return getId;
        }
        catch (error) {
            this.gets.delete(getId);
            throw error;
        }
    }
    async querierGet(data, closure) {
        let getId = IdSource.get();
        this.gets.set(getId, closure);
        try {
            await this.sendMessage(new QuerierGet(getId, data));
            return getId;
        }
        catch (error) {
            this.gets.delete(getId);
            throw error;
        }
    }
    async livelinessGet(data, closure) {
        let getId = IdSource.get();
        this.gets.set(getId, closure);
        try {
            await this.sendMessage(new LivelinessGet(getId, data));
            return getId;
        }
        catch (error) {
            this.gets.delete(getId);
            throw error;
        }
    }
    async replyOk(data) {
        await this.sendMessage(data);
    }
    async replyDel(data) {
        await this.sendMessage(data);
    }
    async replyErr(data) {
        await this.sendMessage(data);
    }
    async sendResponseFinal(queryId) {
        await this.sendMessage(new QueryResponseFinal(queryId));
    }
    async publisherDeclareMatchingListener(publisherId, closure) {
        let listenerId = IdSource.get();
        this.matchingListeners.set(listenerId, closure);
        try {
            await this.sendRequest(new PublisherDeclareMatchingListener(listenerId, publisherId), InRemoteMessageId.ResponseOk, ResponseOk.deserialize);
        }
        catch (error) {
            this.matchingListeners.delete(listenerId);
            throw error;
        }
        return listenerId;
    }
    async undeclareMatchingListener(listenerId) {
        const listener = this.matchingListeners.get(listenerId);
        if (listener == undefined) {
            new Error(`Unknown matching listener id: ${listenerId}`);
        }
        else {
            this.matchingListeners.delete(listenerId);
            listener.drop();
        }
        await this.sendRequest(new UndeclareMatchingListener(listenerId), InRemoteMessageId.ResponseOk, ResponseOk.deserialize);
    }
    async publisherGetMatchingStatus(publisherId) {
        return await this.sendRequest(new PublisherGetMatchingStatus(publisherId), InRemoteMessageId.ResponseMatchingStatus, ResponseMatchingStatus.deserialize).then((value) => new MatchingStatus(value.matching));
    }
    async querierDeclareMatchingListener(querierId, closure) {
        let listenerId = IdSource.get();
        this.matchingListeners.set(listenerId, closure);
        try {
            await this.sendRequest(new QuerierDeclareMatchingListener(listenerId, querierId), InRemoteMessageId.ResponseOk, ResponseOk.deserialize);
        }
        catch (error) {
            this.matchingListeners.delete(listenerId);
            throw error;
        }
        return listenerId;
    }
    async querierGetMatchingStatus(querierId) {
        return await this.sendRequest(new QuerierGetMatchingStatus(querierId), InRemoteMessageId.ResponseMatchingStatus, ResponseMatchingStatus.deserialize).then((value) => new MatchingStatus(value.matching));
    }
    async close() {
        await this.link.close();
        for (let s of this.subscribers) {
            s[1].drop();
        }
        this.subscribers.clear();
        for (let g of this.gets) {
            g[1].drop();
        }
        this.gets.clear();
        for (let q of this.queryables) {
            q[1].drop();
        }
        this.queryables.clear();
        for (let l of this.matchingListeners) {
            l[1].drop();
        }
        this.matchingListeners.clear();
        this.isClosed_ = true;
    }
    isClosed() {
        return this.isClosed_;
    }
    cancelQuery(queryId) {
        let get = this.gets.get(queryId);
        if (get != undefined) {
            this.gets.delete(queryId);
            get.drop();
        }
    }
}
//# sourceMappingURL=session_inner.js.map