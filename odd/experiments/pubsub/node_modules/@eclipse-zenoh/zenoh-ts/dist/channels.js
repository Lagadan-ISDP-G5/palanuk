//
// Copyright (c) 2025 ZettaScale Technology
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0
// which is available at https://www.apache.org/licenses/LICENSE-2.0.
//
// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
//
// Contributors:
//   ZettaScale Zenoh Team, <zenoh@zettascale.tech>
//
import { SimpleChannel, TryReceivedKind, ChannelState } from "channel-ts";
export function isIntoSenderReceiverPair(object) {
    return (object).intoSenderReceiverPair != undefined;
}
export function intoCbDropReceiver(handler) {
    if (isIntoSenderReceiverPair(handler)) {
        let [sender, receiver] = handler.intoSenderReceiverPair();
        let cb = (data) => {
            sender.send(data);
        };
        let drop = () => {
            sender.close();
        };
        return [cb, drop, receiver];
    }
    else if (Array.isArray(handler)) { // [callback, drop]
        return [handler[0], handler[1], undefined];
    }
    else {
        let drop = () => { };
        return [handler, drop, undefined];
    }
}
/**
 * A FIFO channel. When maximum capacity is reached all new values will be ignored.
 */
export class FifoChannel {
    chan;
    capacity;
    size;
    constructor(capacity) {
        this.capacity = capacity;
        this.size = 0;
        this.chan = new SimpleChannel();
    }
    /**
     * Send new data onto channel. When maximum capacity is reached all new values will be ignored.
     */
    send(data) {
        if (this.size != this.capacity) {
            this.chan.send(data);
            this.size++;
        }
    }
    /**
     * Get state of the channel.
     */
    state() {
        return this.chan.state;
    }
    /**
     * Attempt to receive the data in a non-blocking way.
     */
    tryReceive() {
        let res = this.chan.tryReceive();
        if (res.kind == TryReceivedKind.value) {
            this.size--;
        }
        return res;
    }
    /**
     * Receive data in a blocking way. If channel is empty, this call will block until new data arrives or the channel is closed.
     */
    async receive() {
        let res = await this.chan.receive();
        this.size--;
        return res;
    }
    /**
     * Close the channel. This`will unblock all currently pending @see receive calls.
     */
    close() {
        this.chan.close();
    }
    async *[Symbol.asyncIterator]() {
        try {
            while (true) {
                yield await this.receive();
            }
        }
        catch {
        }
    }
    /**
     * Split Channel into @interface ChannelSender and @interface ChannelReceiver pair.
     */
    intoSenderReceiverPair() {
        return [this, this];
    }
}
/**
 * A circular buffer channel. When maximum capacity is reached the older values will be removed to provide space for new ones.
 */
export class RingChannel extends FifoChannel {
    constructor(capacity) {
        super(capacity);
    }
    /**
     * Send new data onto channel. When maximum capacity is reached the older values will be removed to provide space for new ones.
     */
    send(data) {
        if (this.capacity == 0)
            return;
        if (this.size == this.capacity) {
            this.chan.tryReceive();
        }
        this.chan.send(data);
        this.size++;
    }
}
export { TryReceivedKind, ChannelState };
//# sourceMappingURL=channels.js.map